"use strict";
console.oldWarn = console.warn, console.oldError = console.error, console.msg = [], console.warn = function(e, t) {
    let i = document.getElementById("msg-box"),
        s = i.getElementsByClassName("mdui-dialog-content")[0];
    var n;
    console.msg.length <= 0 && (s.innerHTML = ""), console.oldWarn(e), t && console.oldWarn(t), n = this.msg.push(e) - 1, s.innerHTML = '<div class="mdui-card mdui-shadow-0 mdui-m-b-1 mdui-color-orange-100" id="msg-id-' + n + '"><div class="mdui-card-content mdui-p-b-0"><p style="margin-top:0;"><i class="mdui-icon material-icons mdui-m-r-1">&#xe002;</i>' + e + "</p>" + (t ? '<pre style="margin-bottom:0;font-size:14px;overflow:auto">' + t.message + "\n" + t.stack + "</pre>" : "") + '</div><div class="mdui-card-actions"><button onclick="console.deleteMsg(' + n + ')" class="mdui-btn mdui-ripple mdui-float-right">忽略</button></div></div>' + s.innerHTML, mdui.$("#msg-btn").hasClass("mdui-fab-hide") && mdui.$("#msg-btn").removeClass("mdui-fab-hide")
}, console.error = function(e, t) {
    let i = document.getElementById("msg-box"),
        s = i.getElementsByClassName("mdui-dialog-content")[0],
        n;
    console.msg.length <= 0 && (s.innerHTML = ""), console.oldError(e), t && console.oldError(t), n = this.msg.push(e) - 1, s.innerHTML = '<div class="mdui-card mdui-shadow-0 mdui-m-b-1 mdui-color-deep-orange-a700" id="msg-id-' + n + '"><div class="mdui-card-content mdui-p-b-0"><p style="margin-top:0;"><i class="mdui-icon material-icons mdui-m-r-1">&#xe000;</i>' + e + "</p>" + (t ? '<pre style="margin-bottom:0;font-size:14px;overflow:auto">' + t.message + "\n" + t.stack + "</pre>" : "") + '</div><div class="mdui-card-actions"><button onclick="console.deleteMsg(' + n + ')" class="mdui-btn mdui-ripple mdui-float-right">忽略</button></div></div>' + s.innerHTML, mdui.confirm(e + (t ? '<pre style="margin-bottom:0;font-size:14px;overflow:auto">' + t.message + "\n" + t.stack + "</pre>" : ""), "出错啦！", () => { console.deleteMsg(n) }, () => {}, { confirmText: "忽略", cancelText: "关闭" }), mdui.$("#msg-btn").hasClass("mdui-fab-hide") && mdui.$("#msg-btn").removeClass("mdui-fab-hide")
}, console.openMsgBox = () => {
    let e = new mdui.Dialog("#msg-box");
    e.open()
}, console.deleteMsg = e => {
    let t = new mdui.Dialog("#msg-box");
    if (mdui.$("#msg-id-" + e).remove(), console.msg.splice(e, 1), console.msg.length <= 0) {
        let e = document.getElementById("msg-box"),
            t = e.getElementsByClassName("mdui-dialog-content")[0];
        t.innerHTML = '<div class="mdui-text-center mdui-text-color-theme-disabled">还没有新信息哦</div>', mdui.$("#msg-btn").hasClass("mdui-fab-hide") || mdui.$("#msg-btn").addClass("mdui-fab-hide")
    }
    mdui.mutation("#msg-box"), t.handleUpdate()
};
class Cubic {
    constructor(e, t, i, s, n = 1e-6) { this.px3 = 3 * e, this.px2 = 3 * (i - e) - this.px3, this.px1 = 1 - this.px3 - this.px2, this.py3 = 3 * t, this.py2 = 3 * (s - t) - this.py3, this.py1 = 1 - this.py3 - this.py2, this.epsilon = n }
    getX(e) { return ((this.px1 * e + this.px2) * e + this.px3) * e }
    getY(e) { return ((this.py1 * e + this.py2) * e + this.py3) * e }
    solve(e) {
        if (0 === e || 1 === e) return this.getY(e);
        if (e < 0) return 0;
        if (1 < e) return 1;
        let t = e;
        for (let n = 0; n < 8; n++) {
            var i = this.getX(t) - e;
            if (Math.abs(i) < this.epsilon) return this.getY(t);
            var s = (3 * this.px1 * t + 2 * this.px2) * t + this.px3;
            if (Math.abs(s) < 1e-6) break;
            t -= i / s
        }
        return this.getY(t)
    }
}
class Timer {
    constructor() { this.startTime = 0, this.isPaused = !1, this.isStoped = !0 }
    static create() { let e = new Timer; return e.start(), e }
    start() { this.startTime = Date.now(), this.isPaused = !1, this.isStoped = !1 }
    pause() { return this.isPaused || this.isStoped || (this._lastDuration = Date.now() - this.startTime, this.startTime = Date.now(), this.isPaused = !0), this._lastDuration / 1e3 }
    stop() { return this.isStoped || (this._lastDuration = Date.now() - this.startTime, this.startTime = Date.now(), this.isPaused = !1, this.isStoped = !0), this._lastDuration / 1e3 }
    toggle() { return this.isPaused ? (this.startTime = Date.now() - this._lastDuration, this._lastDuration = void 0, this.isPaused = !1, (Date.now() - this.startTime) / 1e3) : this.pause() }
    get time() { return this.isPaused || this.isStoped ? (this.startTime = Date.now(), this._lastDuration / 1e3) : (Date.now() - this.startTime) / 1e3 }
}
class Click {
    constructor(e, t, i = null, s = null) { this.offsetX = Number(e), this.offsetY = Number(t), this.isMoving = !1, this.time = 0, this.type = i, this.inputId = Number(s) }
    static activate(e, t, i = null, s = null) { return inputs.taps.push(new Click(e, t, i, s)), e < 1.5 * pixi.renderer.lineScale && t < 1.5 * pixi.renderer.lineScale && specialClick.click(0), e > pixi.renderer.realWidth - 1.5 * pixi.renderer.lineScale && t < 1.5 * pixi.renderer.lineScale && specialClick.click(1), e < 1.5 * pixi.renderer.lineScale && t > pixi.renderer.realHeight - 1.5 * pixi.renderer.lineScale && specialClick.click(2), e > pixi.renderer.realWidth - 1.5 * pixi.renderer.lineScale && t > pixi.renderer.realHeight - 1.5 * pixi.renderer.lineScale && specialClick.click(3), new Click(e, t, i, s) }
    move(e, t) { this.offsetX = Number(e), this.offsetY = Number(t), this.isMoving = !0, this.time = 0 }
    animate() { this.time++ ? DrawInputPoint(this.offsetX, this.offsetY, this.type, this.inputId, 2) : this.isMoving ? DrawInputPoint(this.offsetX, this.offsetY, this.type, this.inputId, 1) : DrawInputPoint(this.offsetX, this.offsetY, this.type, this.inputId, 0) }
}
class Judgement {
    constructor(e, t, i) { this.offsetX = Number(e), this.offsetY = Number(t), this.type = Number(i) || 0, this.catched = !1 }
    isInArea(e, t, i, s, n, r = 0) { let a = (this.offsetX - e) * i + (this.offsetY - t) * s; return (a = 0 < a ? a : -a) <= n }
}
class Judgements extends Array {
    addJudgement(e, t) {
        if (!stat.isPaused)
            if (this.length = 0, settings.autoPlay)
                for (const l of e) {
                    var i, s;
                    0 < l.raw.score && (l.raw.isProcessed || l.raw.isScored) || l.raw.realTime - t > global.judgeTimes.bad || (i = getNotePosition(l, !1).x, s = getNotePosition(l, !1).y, 1 == l.raw.type ? l.raw.realTime - t < 0 && this.push(new Judgement(i, s, 1)) : 2 == l.raw.type ? l.raw.realTime - t < global.judgeTimes.bad && this.push(new Judgement(i, s, 2)) : 3 == l.raw.type ? l.raw.isPressing ? this.push(new Judgement(i, s, 2)) : l.raw.realTime - t < 0 && this.push(new Judgement(i, s, 1)) : 4 == l.raw.type && l.raw.realTime - t < global.judgeTimes.bad && this.push(new Judgement(i, s, 3)))
                } else {
                    for (var n in inputs.mouse) {
                        n = inputs.mouse[n];
                        n instanceof Click && (n.time ? this.push(new Judgement(n.offsetX, n.offsetY, 2)) : n.isMoving && this.push(new Judgement(n.offsetX, n.offsetY, 3)))
                    }
                    for (var r in inputs.touches) {
                        r = inputs.touches[r];
                        r instanceof Click && (r.time ? this.push(new Judgement(r.offsetX, r.offsetY, 2)) : r.isMoving && this.push(new Judgement(r.offsetX, r.offsetY, 3)))
                    }
                    for (var a in inputs.keyboard) {
                        a = inputs.keyboard[a];
                        a instanceof Click && (a.time ? this.push(new Judgement(a.offsetX, a.offsetY, 2)) : this.push(new Judgement(a.offsetX, a.offsetY, 3)))
                    }
                    for (var o of inputs.taps) o instanceof Click && this.push(new Judgement(o.offsetX, o.offsetY, 1))
                }
    }
    judgeNote(e, t, i) {
        if (stat.isTransitionEnd && !stat.isPaused)
            for (const u of e) {
                var s = u.raw.realTime - t,
                    n = 0 < s ? s : -s;
                if (!(0 < u.raw.score && u.raw.isProcessed) && !(s > global.judgeTimes.bad))
                    if (s < -global.judgeTimes.bad && !u.raw.isProcessed && !u.raw.isPressing && !u.raw.isScored) score.addCombo(1), u.raw.score = 1, u.raw.isProcessed = !0, u.raw.isScored = !0, 3 == u.type && (u.alpha = .5, u.raw.isProcessed = !1);
                    else {
                        var r = u.raw,
                            a = getNotePosition(u, !1),
                            o = a.x,
                            l = a.y,
                            d = a.cosr,
                            c = a.sinr;
                        if (1 == r.type) {
                            for (let e = 0; e < this.length; e++)
                                if (1 == this[e].type && this[e].isInArea(o, l, d, c, i) && n <= global.judgeTimes.bad && !r.isProcessed && (n <= global.judgeTimes.perfect ? u.raw.score = 4 : n <= global.judgeTimes.good ? u.raw.score = 3 : u.raw.score = 2, 0 < u.raw.score)) { score.addCombo(u.raw.score, s), u.visible = !1, CreateClickAnimation(u, settings.performanceMode), settings.hitsound && 2 < u.score && textures.sound.tap.play({ volume: settings.hitsoundVolume }), sprites.accIndicator && sprites.accIndicator.pushAccurate(r.realTime, t), u.raw.isProcessed = !0, this.splice(e, 1); break }
                        } else if (2 == r.type) {
                            if (0 < r.score && s < 0 && !r.isProcessed) score.addCombo(r.score), note.visible = !1, CreateClickAnimation(u, settings.performanceMode), settings.hitsound && textures.sound.drag.play({ volume: settings.hitsoundVolume }), sprites.accIndicator && sprites.accIndicator.pushAccurate(r.realTime, t), u.isProcessed = !0;
                            else if (!r.isProcessed)
                                for (let e = 0; e < this.length; e++)
                                    if (this[e].isInArea(o, l, d, c, i) && n <= global.judgeTimes.good) { this[e].catched = !0, u.raw.score = 4; break }
                        } else if (3 == r.type)
                            if (r.isPressing && r.pressTime && ((Date.now() - r.pressTime) * r.holdTime >= 16e3 * r.realHoldTime && !r.isScored && (CreateClickAnimation(u, settings.performanceMode), u.raw.pressTime = Date.now()), r.realTime + r.realHoldTime - global.judgeTimes.bad < t && r.isPressing)) 0 < r.score && !r.isScored && (score.addCombo(r.score, r.accType), u.raw.isScored = !0), r.realTime + r.realHoldTime < t && (note.visible = !1, u.raw.isProcessed = !0);
                            else {
                                u.raw.isPressing = !1;
                                for (let e = 0; e < this.length; e++)
                                    if (r.pressTime || r.isPrecessed || r.isScored) r.isScored || r.isProcessed || !this[e].isInArea(o, l, d, c, i) || (u.raw.isPressing = !0);
                                    else if (1 == this[e].type && this[e].isInArea(o, l, d, c, i) && n < global.judgeTimes.good) { n <= global.judgeTimes.perfect ? u.raw.score = 4 : u.raw.score = 3, u.raw.isPressing = !0, u.raw.accType = s, u.raw.pressTime = Date.now(), CreateClickAnimation(u, settings.performanceMode), settings.hitsound && textures.sound.tap.play({ volume: settings.hitsoundVolume }), sprites.accIndicator && sprites.accIndicator.pushAccurate(r.realTime, t), this.splice(e, 1); break }
                                stat.isPaused || !(0 < u.raw.score) || u.raw.isPressing || u.raw.pressTime || u.raw.isScored || (u.raw.score = 1, score.addCombo(1), u.raw.isScored = !0, u.alpha = .5)
                            }
                        else if (4 == r.type)
                            if (0 < r.score && s < 0 && !r.isProcessed) u.visible = !1, score.addCombo(r.score), CreateClickAnimation(u, settings.performanceMode), settings.hitsound && textures.sound.flick.play({ volume: settings.hitsoundVolume }), sprites.accIndicator && sprites.accIndicator.pushAccurate(r.realTime, t), u.raw.isProcessed = !0;
                            else if (!r.isProcessed)
                            for (let e = 0; e < this.length; e++)
                                if (this[e].isInArea(o, l, d, c, i) && n <= global.judgeTimes.good && (this[e].catched = !0, 3 == this[e].type)) { u.raw.score = 4; break }
                    }
            }
    }
    judgeSingleNote(s, e, n, r) {
        if (stat.isTransitionEnd && !stat.isPaused) {
            var a = s.realTime - n,
                o = 0 < a ? a : -a;
            if (!(0 < s.score && s.isScored)) {
                if (a < -global.judgeTimes.bad) { if (3 != s.type) return score.addCombo(1), s.score = 1, void(s.isScored = !0); if (3 === s.type && !s.isPressing) return score.addCombo(1), s.score = 1, void(s.isScored = !0) }
                var l = e.x,
                    d = e.y,
                    c = e.cosr,
                    u = e.sinr,
                    m = e.angle;
                switch (s.type) {
                    case 1:
                        for (let e = 0; e < this.length; e++)
                            if (1 == this[e].type && this[e].isInArea(l, d, c, u, r) && o <= global.judgeTimes.bad && (o <= global.judgeTimes.perfect ? s.score = 4 : o <= global.judgeTimes.good ? s.score = 3 : s.score = 2, 0 < s.score)) return score.addCombo(s.score, a), CreateClickAnimation(l, d, m, s.score, settings.performanceMode), PlayHitsound(s, settings.hitsoundVolume), sprites.ui.game.head.accIndicator && sprites.ui.game.head.accIndicator.pushAccurate(s.realTime, n), s.isScored = !0, void this.splice(e, 1);
                        break;
                    case 2:
                        if (0 < s.score && a < 0) score.addCombo(s.score), CreateClickAnimation(l, d, m, s.score, settings.performanceMode), PlayHitsound(s, settings.hitsoundVolume), sprites.ui.game.head.accIndicator && sprites.ui.game.head.accIndicator.pushAccurate(s.realTime, n), s.isScored = !0;
                        else
                            for (let e = 0; e < this.length; e++)
                                if (this[e].isInArea(l, d, c, u, r) && o <= global.judgeTimes.good) return this[e].catched = !0, void(s.score = 4); break;
                    case 3:
                        if (2 < s.score && s.isPressing && s.pressTime) { if ((n - s.pressTime) * s.holdTime >= 16 * s.realHoldTime) return CreateClickAnimation(l, d, m, s.score, settings.performanceMode), void(s.pressTime = n); if (s.realTime + s.realHoldTime - global.judgeTimes.bad < n && s.isPressing) return void(0 < s.score && (score.addCombo(s.score, s.accType), s.isScored = !0)) }
                        s.isPressing = !1;
                        for (let t = 0; t < this.length; t++)
                            if (s.pressTime || s.isPressing) 2 < s.score && this[t].isInArea(l, d, c, u, r) && (s.isPressing = !0);
                            else if (1 == this[t].type && this[t].isInArea(l, d, c, u, r) && o < global.judgeTimes.good) return o <= global.judgeTimes.perfect ? s.score = 4 : s.score = 3, s.isPressing = !0, s.accType = a, s.pressTime = n, CreateClickAnimation(l, d, m, s.score, settings.performanceMode), PlayHitsound(s, settings.hitsoundVolume), sprites.ui.game.head.accIndicator && sprites.ui.game.head.accIndicator.pushAccurate(s.realTime, n), void this.splice(t, 1);
                        if (!stat.isPaused && 0 < s.score && !s.isPressing && !s.pressTime) return score.addCombo(1), s.score = 1, void(s.isScored = !0);
                        break;
                    case 4:
                        if (0 < s.score && a < 0) return score.addCombo(s.score), CreateClickAnimation(l, d, m, s.score, settings.performanceMode), PlayHitsound(s, settings.hitsoundVolume), sprites.ui.game.head.accIndicator && sprites.ui.game.head.accIndicator.pushAccurate(s.realTime, n), void(s.isScored = !0);
                        for (let i = 0; i < this.length; i++)
                            if (this[i].isInArea(l, d, c, u, r) && o <= global.judgeTimes.good && (this[i].catched = !0, 3 == this[i].type)) return void(s.score = 4);
                        break;
                    default:
                        throw new error("一个不被支持的 Note 类型：" + s.type)
                }
            }
        }
    }
}
const tween = [null, null, e => Math.sin(e * Math.PI / 2), e => 1 - Math.cos(e * Math.PI / 2), e => 1 - (e - 1) ** 2, e => e ** 2, e => (1 - Math.cos(e * Math.PI)) / 2, e => ((e *= 2) < 1 ? e ** 2 : -((e - 2) ** 2 - 2)) / 2, e => 1 + (e - 1) ** 3, e => e ** 3, e => 1 - (e - 1) ** 4, e => e ** 4, e => ((e *= 2) < 1 ? e ** 3 : (e - 2) ** 3 + 2) / 2, e => ((e *= 2) < 1 ? e ** 4 : -((e - 2) ** 4 - 2)) / 2, e => 1 + (e - 1) ** 5, e => e ** 5, e => 1 - 2 ** (-10 * e), e => 2 ** (10 * (e - 1)), e => Math.sqrt(1 - (e - 1) ** 2), e => 1 - Math.sqrt(1 - e ** 2), e => (2.70158 * e - 1) * (e - 1) ** 2 + 1, e => (2.70158 * e - 1.70158) * e ** 2, e => ((e *= 2) < 1 ? 1 - Math.sqrt(1 - e ** 2) : Math.sqrt(1 - (e - 2) ** 2) + 1) / 2, e => e < .5 ? (14.379638 * e - 5.189819) * e ** 2 : (14.379638 * e - 9.189819) * (e - 1) ** 2 + 1, e => 1 - 2 ** (-10 * e) * Math.cos(e * Math.PI / .15), e => 2 ** (10 * (e - 1)) * Math.cos((e - 1) * Math.PI / .15), e => ((e *= 11) < 4 ? e ** 2 : e < 8 ? (e - 6) ** 2 + 12 : e < 10 ? (e - 9) ** 2 + 15 : (e - 10.5) ** 2 + 15.75) / 16, e => 1 - tween[26](1 - e), e => (e *= 2) < 1 ? tween[26](e) / 2 : tween[27](e - 1) / 2 + .5, e => e < .5 ? 2 ** (20 * e - 11) * Math.sin((160 * e + 1) * Math.PI / 18) : 1 - 2 ** (9 - 20 * e) * Math.sin((160 * e + 1) * Math.PI / 18)];

function ConvertPEC2Json(D, e) {
    class t {
        numOfNotes = 0;
        numOfNotesAbove = 0;
        numOfNotesBelow = 0;
        bpm = 120;
        constructor(e) { this.bpm = e, "speedEvents,notesAbove,notesBelow,notesFakeAbove,notesFakeBelow,judgeLineDisappearEvents,judgeLineMoveEvents,judgeLineRotateEvents,judgeLineDisappearEventsPec,judgeLineMoveEventsPec,judgeLineRotateEventsPec".split(",").map(e => this[e] = []) }
        pushNote(e, t, i) {
            switch (e.isFake = !!i, t) {
                case void 0:
                case 1:
                    (i ? this.notesFakeAbove : this.notesAbove).push(e);
                    break;
                case 2:
                    (i ? this.notesFakeBelow : this.notesBelow).push(e);
                    break;
                default:
                    throw "Note 参数错误：错误的 Note 位置：" + t
            }
            i || (this.numOfNotes++, this.numOfNotesAbove++)
        }
        pushEvent(e, t, i, s, n, r, a) {
            const o = { startTime: t, endTime: i };
            switch ("number" == typeof t && "number" == typeof i && i < t && console.warn("判定线事件错误：事件起始时间（" + t + "）大于结束时间（" + i + "）"), e) {
                case 0:
                    o.value = s, this.speedEvents.push(o);
                    break;
                case 1:
                    o.start = s, o.end = n, o.start2 = 0, o.end2 = 0, this.judgeLineDisappearEvents.push(o);
                    break;
                case 2:
                    o.start = s, o.end = n, o.start2 = r, o.end2 = a, this.judgeLineMoveEvents.push(o);
                    break;
                case 3:
                    o.start = s, o.end = n, o.start2 = 0, o.end2 = 0, this.judgeLineRotateEvents.push(o);
                    break;
                case -1:
                    o.value = s, o.motionType = 1, this.judgeLineDisappearEventsPec.push(o);
                    break;
                case -2:
                    o.value = s, o.value2 = n, o.motionType = r, this.judgeLineMoveEventsPec.push(o);
                    break;
                case -3:
                    o.value = s, o.motionType = n, this.judgeLineRotateEventsPec.push(o);
                    break;
                default:
                    throw "判定线事件错误：无效的事件类型：" + e
            }
        }
    }
    class i { constructor(e, t, i, s, n) { this.type = e, this.time = t, this.positionX = i, this.holdTime = 3 == e ? s : 0, this.speed = isNaN(n) ? 1 : n } }
    let s = D.match(/[^\n\r ]+/g).map(e => (isNaN(e) ? String : Number)(e)),
        X = new class {
            constructor() { this.formatVersion = 3, this.offset = 0, this.numOfNotes = 0, this.judgeLineList = [] }
            pushLine(e) { return this.judgeLineList.push(e), this.numOfNotes += e.numOfNotes, e }
        },
        n = {},
        r = [],
        a = "",
        o = [1, 1],
        l, H = [],
        d = [];
    isNaN(s[0]) || (X.offset = s.shift() / 1e3 - .175), "bp,n1,n2,n3,n4,cv,cp,cd,ca,cm,cr,cf".split(",").map(e => n[e] = []);
    for (let L = 0; L < s.length; L++) {
        var c = s[L];
        if (isNaN(c))
            if ("#" == c && "n" == a[0]) o[0] = s[++L];
            else if ("&" == c && "n" == a[0]) o[1] = s[++L];
        else {
            if (!n[c]) throw "谱面参数错误：未知的指令：" + c;
            Z(c)
        } else r.push(c)
    }
    Z(""), n.bp[0] || n.bp.push([0, 120]), l = n.bp[0][1], n.bp[0][0] && n.bp.unshift([0, l]);
    let R = 0;
    n.bp.sort((e, t) => e[0] - t[0]).forEach((e, t, i) => {
        var s, n, r;
        i[t + 1] && i[t + 1][0] <= 0 || (s = e[0] < 0 ? 0 : e[0], n = i[t + 1] ? i[t + 1][0] : 1e9, r = e[1], H.push({ startTime: s, endTime: n, bpm: r, value: R }), R += (n - s) / r)
    });
    for (var u of n.n1) d[u[0]] || (d[u[0]] = new t(l)), d[u[0]].pushNote(new i(1, F(u[1]) + (u[4] ? 1e9 : 0), 9 * u[2] / 1024, 0, u[5]), u[3], u[4]), u[4] && console.warn('检测到 FakeNote，该 Note 可能会产生显示异常。\n位于："n1 ' + u.slice(0, 5).join(" ") + '"\n来自 ' + e), 1 != u[6] && console.warn('检测到异常 Note，该 Note 可能会产生显示异常。\n位于："n1 ' + u.slice(0, 5).join(" ") + " # " + u[5] + " & " + u[6] + '"\n来自 ' + e);
    for (var m of n.n4) d[m[0]] || (d[m[0]] = new t(l)), d[m[0]].pushNote(new i(2, F(m[1]) + (m[4] ? 1e9 : 0), 9 * m[2] / 1024, 0, m[5]), m[3], m[4]), m[4] && console.warn('检测到 FakeNote，该 Note 可能会产生显示异常。\n位于："n1 ' + m.slice(0, 5).join(" ") + '"\n来自 ' + e), 1 != m[6] && console.warn('检测到异常 Note，该 Note 可能会产生显示异常。\n位于："n1 ' + m.slice(0, 5).join(" ") + " # " + m[5] + " & " + m[6] + '"\n来自 ' + e);
    for (var h of n.n2) d[h[0]] || (d[h[0]] = new t(l)), d[h[0]].pushNote(new i(3, F(h[1]) + (h[5] ? 1e9 : 0), 9 * h[3] / 1024, F(h[2]) - F(h[1]), h[6]), h[4], h[5]), h[5] && console.warn('检测到 FakeNote，该 Note 可能会产生显示异常。\n位于："n2 ' + h.slice(0, 6).join(" ") + '"\n来自 ' + e), 1 != h[7] && message.sendWarning('检测到异常 Note，该 Note 可能会产生显示异常。\n位于:"n2 ' + h.slice(0, 5).join(" ") + " # " + h[6] + " & " + h[7] + '"\n来自 ' + e);
    for (var g of n.n3) d[g[0]] || (d[g[0]] = new t(l)), d[g[0]].pushNote(new i(4, F(g[1]) + (g[4] ? 1e9 : 0), 9 * g[2] / 1024, 0, g[5]), g[3], g[4]), g[4] && console.warn('检测到 FakeNote，该 Note 可能会产生显示异常。\n位于："n1 ' + g.slice(0, 5).join(" ") + '"\n来自 ' + e), 1 != g[6] && console.warn('检测到异常 Note，该 Note 可能会产生显示异常。\n位于："n1 ' + g.slice(0, 5).join(" ") + " # " + g[5] + " & " + g[6] + '"\n来自 ' + e);
    for (var p of n.cv) d[p[0]] || (d[p[0]] = new t(l)), d[p[0]].pushEvent(0, F(p[1]), null, p[2] / 7);
    for (var f of n.ca) d[f[0]] || (d[f[0]] = new t(l)), d[f[0]].pushEvent(-1, F(f[1]), F(f[1]), 0 < f[2] ? f[2] / 255 : 0), f[2] < 0 && console.warn("检测到负数 Alpha:" + f[2] + '，该值将会被转换为 0。\n位于："ca ' + f.join(" ") + '"\n来自 ' + e);
    for (var v of n.cf) d[v[0]] || (d[v[0]] = new t(l)), v[1] > v[2] ? console.warn('检测到事件时间轴不正确，该事件将被禁用。\n位于："cf ' + v.join(" ") + '"\n来自 ' + e) : (d[v[0]].pushEvent(-1, F(v[1]), F(v[2]), 0 < v[3] ? v[3] / 255 : 0), v[3] < 0 && console.warn("检测到负数 Alpha:" + v[3] + '，该值将会被转换为 0。\n位于："cf ' + v.join(" ") + '"\n来自 ' + e));
    for (var b of n.cp) d[b[0]] || (d[b[0]] = new t(l)), d[b[0]].pushEvent(-2, F(b[1]), F(b[1]), b[2] / 2048, b[3] / 1400, 1);
    for (var x of n.cm) d[x[0]] || (d[x[0]] = new t(l)), x[1] > x[2] ? console.warn('检测到事件时间轴不正确，该事件将被禁用。\n位于："cm ' + x.join(" ") + '"\n来自 ' + e) : (d[x[0]].pushEvent(-2, F(x[1]), F(x[2]), x[3] / 2048, x[4] / 1400, x[5]), x[5] && !tween[x[5]] && 1 != x[5] && console.warn("检测到未知的移动类型：" + x[5] + '，该值将会被转换为 1。\n位于："cm ' + x.join(" ") + '"\n来自 ' + e));
    for (var w of n.cd) d[w[0]] || (d[w[0]] = new t(l)), d[w[0]].pushEvent(-3, F(w[1]), F(w[1]), -w[2], 1);
    for (var T of n.cr) d[T[0]] || (d[T[0]] = new t(l)), T[1] > T[2] ? console.warn('检测到事件时间轴不正确，该事件将被禁用。\n位于："cr ' + T.join(" ") + '"\n来自 ' + e) : (d[T[0]].pushEvent(-3, F(T[1]), F(T[2]), -T[3], T[4]), T[4] && !tween[T[4]] && 1 != T[4] && console.warn("检测到未知的旋转类型：" + T[4] + '，该值将会被转换为 1。\n位于："cr ' + T.join(" ") + '"\n来自 ' + e));
    for (var y of d)
        if (y) {
            var O = (e, t) => e.startTime - t.startTime + (e.endTime - t.endTime);
            let i = y.speedEvents,
                e = y.judgeLineMoveEventsPec,
                s = y.judgeLineRotateEventsPec,
                n = y.judgeLineDisappearEventsPec;
            if (!(y.notesAbove.length <= 0 && y.notesBelow.length <= 0 && i.length <= 1 && e.length <= 1 && s.length <= 1 && n.length <= 1)) {
                y.notesAbove.sort((e, t) => e.time - t.time), y.notesBelow.sort((e, t) => e.time - t.time), y.notesFakeAbove.sort((e, t) => e.time - t.time), y.notesFakeBelow.sort((e, t) => e.time - t.time), i.sort(O), e.sort(O), s.sort(O), n.sort(O); { let e = 0; for (let t = 0; t < i.length; t++) i[t].endTime = t < i.length - 1 ? i[t + 1].startTime : 1e9, i[t].startTime < t && (i[t].startTime = 0), i[t].floorPosition = e, e += (i[t].endTime - i[t].startTime) * i[t].value / y.bpm * 1.875 }
                for (var I of y.notesAbove) {
                    let e = 0,
                        t = 0,
                        i = 0;
                    for (var C of y.speedEvents)
                        if (!(I.time % 1e9 > C.endTime)) {
                            if (I.time % 1e9 < C.startTime) break;
                            e = C.value, t = C.floorPosition, i = I.time % 1e9 - C.startTime
                        }
                    I.floorPosition = t + e * i / y.bpm * 1.875, 3 == I.type && (I.speed *= e)
                }
                for (var k of y.notesBelow) {
                    let e = 0,
                        t = 0,
                        i = 0;
                    for (var P of y.speedEvents)
                        if (!(k.time % 1e9 > P.endTime)) {
                            if (k.time % 1e9 < P.startTime) break;
                            e = P.value, t = P.floorPosition, i = k.time % 1e9 - P.startTime
                        }
                    k.floorPosition = t + e * i / y.bpm * 1.875, 3 == k.type && (k.speed *= e)
                }
                for (var j of y.notesFakeAbove) {
                    let e = 0,
                        t = 0,
                        i = 0;
                    for (var S of y.speedEvents)
                        if (!(j.time % 1e9 > S.endTime)) {
                            if (j.time % 1e9 < S.startTime) break;
                            e = S.value, t = S.floorPosition, i = j.time % 1e9 - S.startTime
                        }
                    j.floorPosition = t + e * i / y.bpm * 1.875, 3 == j.type && (j.speed *= e)
                }
                for (var N of y.notesFakeBelow) {
                    let e = 0,
                        t = 0,
                        i = 0;
                    for (var E of y.speedEvents)
                        if (!(N.time % 1e9 > E.endTime)) {
                            if (N.time % 1e9 < E.startTime) break;
                            e = E.value, t = E.floorPosition, i = N.time % 1e9 - E.startTime
                        }
                    N.floorPosition = t + e * i / y.bpm * 1.875, 3 == N.type && (N.speed *= e)
                } {
                    let t = 0,
                        i = 0;
                    for (var A of n) {
                        if (y.pushEvent(1, t, A.startTime, i, i), tween[A.motionType])
                            for (let e = parseInt(A.startTime); e < parseInt(A.endTime); e++) {
                                var z = (e - A.startTime) / (A.endTime - A.startTime),
                                    J = (e + 1 - A.startTime) / (A.endTime - A.startTime),
                                    W = A.value - i;
                                y.pushEvent(1, e, e + 1, i + tween[A.motionType](z) * W, i + tween[A.motionType](J) * W)
                            } else A.motionType && y.pushEvent(1, A.startTime, A.endTime, i, A.value);
                        t = A.endTime, i = A.value
                    }
                    y.pushEvent(1, t, 1e9, i, i)
                } {
                    let t = 0,
                        i = 0,
                        s = 0;
                    for (const M of e) {
                        if (y.pushEvent(2, t, M.startTime, i, i, s, s), tween[M.motionType])
                            for (let e = parseInt(M.startTime); e < parseInt(M.endTime); e++) {
                                var _ = (e - M.startTime) / (M.endTime - M.startTime),
                                    Y = (e + 1 - M.startTime) / (M.endTime - M.startTime),
                                    G = M.value - i,
                                    V = M.value2 - s;
                                y.pushEvent(2, e, e + 1, i + tween[M.motionType](_) * G, i + tween[M.motionType](Y) * G, s + tween[M.motionType](_) * V, s + tween[M.motionType](Y) * V)
                            } else M.motionType && y.pushEvent(2, M.startTime, M.endTime, i, M.value, s, M.value2);
                        t = M.endTime, i = M.value, s = M.value2
                    }
                    y.pushEvent(2, t, 1e9, i, i, s, s)
                } {
                    let t = 0,
                        i = 0;
                    for (const B of s) {
                        if (y.pushEvent(3, t, B.startTime, i, i), tween[B.motionType])
                            for (let e = parseInt(B.startTime); e < parseInt(B.endTime); e++) {
                                var $ = (e - B.startTime) / (B.endTime - B.startTime),
                                    q = (e + 1 - B.startTime) / (B.endTime - B.startTime),
                                    U = B.value - i;
                                y.pushEvent(3, e, e + 1, i + tween[B.motionType]($) * U, i + tween[B.motionType](q) * U)
                            } else B.motionType && y.pushEvent(3, B.startTime, B.endTime, i, B.value);
                        t = B.endTime, i = B.value
                    }
                    y.pushEvent(3, t, 1e9, i, i), X.pushLine(y)
                }
            }
        }
    return JSON.parse(JSON.stringify(X));

    function Z(e) { n[a] && ("n" == a[0] && (r.push(...o), o = [1, 1]), n[a].push(JSON.parse(JSON.stringify(r)))), r.length = 0, a = e }

    function F(e) {
        let t = 0;
        for (const i of H) {
            if (e < i.startTime) break;
            e > i.endTime || (t = Math.round(((e - i.startTime) / i.bpm + i.value) * l * 32))
        }
        return t
    }
}

function ConvertChartVersion(e) {
    let t = JSON.parse(JSON.stringify(e));
    switch (t.formatVersion) {
        case 1:
            t.formatVersion = 3;
            for (const i of t.judgeLineList) { let e = 0; for (const s of i.speedEvents) s.startTime < 0 && (s.startTime = 0), s.floorPosition = e, e += (s.endTime - s.startTime) * s.value / i.bpm * 1.875; for (const n of i.judgeLineDisappearEvents) n.start2 = 0, n.end2 = 0; for (const r of i.judgeLineMoveEvents) r.start2 = r.start % 1e3 / 520, r.end2 = r.end % 1e3 / 520, r.start = parseInt(r.start / 1e3) / 880, r.end = parseInt(r.end / 1e3) / 880; for (const a of i.judgeLineRotateEvents) a.start2 = 0, a.end2 = 0 }
        case 3:
        case 3473:
            break;
        default:
            throw "谱面数据错误：未知的谱面格式版本：" + t.formatVersion
    }
    return t
}

function Csv2Array(e, t) {
    const s = [];
    for (const n of e.replace(/\r/g, "").split("\n")) {
        let e = "",
            t = !1,
            i = !1;
        const r = [];
        for (const a of n)
            if ('"' == a) t ? i = !i || (e += a, !1) : t = !0;
            else if ("," == a) t ? i ? (r.push(e), e = "", t = !1, i = !1) : e += a : (r.push(e), e = "");
        else {
            if (i) throw "Error 1";
            e += a
        }
        if (t) {
            if (!i) throw "Error 2";
            r.push(e), e = "", t = !1, i = !1
        } else r.push(e), e = "";
        s.push(r)
    }
    if (!t) return s;
    const i = [];
    for (let o = 1; o < s.length; o++) {
        const l = {};
        for (let e = 0; e < s[0].length; e++) l[s[0][e]] = s[o][e];
        i.push(l)
    }
    return i
}
global.functions = {}, global.functions.resizeCanvas = function() {
    var e;
    pixi && (e = document.getElementById("game-canvas-box"), stat.isFullscreen && fullscreen.check(pixi.view) ? pixi.renderer.resize(document.documentElement.clientWidth, document.documentElement.clientHeight) : (stat.isFullscreen && pixi.renderer.resize(1, 1), pixi.renderer.resize(e.offsetWidth, e.offsetWidth * (1 / settings.windowRatio)), stat.isFullscreen = !1), pixi.renderer.realWidth = pixi.renderer.width / pixi.renderer.resolution, pixi.renderer.realHeight = pixi.renderer.height / pixi.renderer.resolution, pixi.renderer.fixedWidth = pixi.renderer.realWidth <= pixi.renderer.realHeight / 9 * 16 ? pixi.renderer.realWidth : pixi.renderer.realHeight / 9 * 16, pixi.renderer.fixedWidthPercent = pixi.renderer.fixedWidth / 18, pixi.renderer.fixedWidthOffset = (pixi.renderer.realWidth - pixi.renderer.fixedWidth) / 2, pixi.renderer.noteSpeed = .6 * pixi.renderer.realHeight, pixi.renderer.noteScale = pixi.renderer.fixedWidth / settings.noteScale, pixi.renderer.lineScale = pixi.renderer.fixedWidth > .75 * pixi.renderer.realHeight ? pixi.renderer.realHeight / 18.75 : pixi.renderer.fixedWidth / 14.0625, ResizeChartSprites(sprites, pixi.renderer.realWidth, pixi.renderer.realHeight, settings.noteScale))
}, global.functions.sortNote = (t, i) => { try { return t.raw.realTime - i.raw.realTime || t.raw.lineId - i.raw.lineId || t.raw.id - i.raw.id } catch (e) { return t.realTime - i.realTime || t.lineId - i.lineId || t.id - i.id } };
const score = {
        init: function(e, t = !1) { return this.totalNotes = e, this.challenge = t, this.score = 0, this.combo = 0, this.maxCombo = 0, this.judge = 0, this.apType = 2, this.perfect = 0, this.good = 0, this.bad = 0, this.miss = 0, this.acc = 0, this.accArray = [], this.scorePerNote = (t ? 1e6 : 9e5) / e, this },
        addCombo: function(e, t = 0) {
            switch (e) {
                case 4:
                    this.perfect += 1, this.combo += 1;
                    break;
                case 3:
                    this.good += 1, this.combo += 1;
                    break;
                case 2:
                    this.bad += 1, this.combo = 0;
                    break;
                default:
                    this.miss += 1, this.combo = 0
            }
            for (t && this.accArray.push(t), this.combo > this.maxCombo && (this.maxCombo = this.combo), this.score = this.scorePerNote * this.perfect + this.scorePerNote * this.good * .65, this.challenge || (this.score += this.maxCombo / this.totalNotes * 1e5), this.score = this.score.toFixed(0), 1e6 <= this.score ? this.judge = 6 : 96e4 <= this.score ? this.judge = 5 : 92e4 <= this.score ? this.judge = 4 : 88e4 <= this.score ? this.judge = 3 : 82e4 <= this.score ? this.judge = 2 : 7e5 <= this.score ? this.judge = 1 : 0 < this.score ? this.judge = 0 : this.judge = -1, this.acc = ((this.perfect + .65 * this.good) / (this.perfect + this.good + this.bad + this.miss) * 100).toFixed(2), this.scoreText = this.score + ""; this.scoreText.length < 7;) this.scoreText = "0" + this.scoreText;
            if ((0 < this.bad || 0 < this.miss) && 0 < this.apType) {
                if (this.apType = 0, settings.showApStatus) {
                    for (var i of sprites.game.judgeLines) i.tint = 16777215;
                    sprites.ui.start.fakeJudgeline && (sprites.ui.start.fakeJudgeline.tint = 16777215)
                }
            } else if (0 < this.good && 1 < this.apType && (this.apType = 1, settings.showApStatus)) {
                for (var s of sprites.game.judgeLines) s.tint = 11854335;
                sprites.ui.start.fakeJudgeline && (sprites.ui.start.fakeJudgeline.tint = 11854335)
            }
            if (sprites.ui.game.head.scoreText.text = this.scoreText, 2 < this.combo ? (sprites.ui.game.head.comboText.alpha = 1, sprites.ui.game.head.comboText.children[0].text = this.combo) : sprites.ui.game.head.comboText.alpha = 0, sprites.judgeRealTime) {
                switch (this.judge) {
                    case 0:
                        sprites.judgeRealTime.judge.text = "Judge: False";
                        break;
                    case 1:
                        sprites.judgeRealTime.judge.text = "Judge: C";
                        break;
                    case 2:
                        sprites.judgeRealTime.judge.text = "Judge: B";
                        break;
                    case 3:
                        sprites.judgeRealTime.judge.text = "Judge: A";
                        break;
                    case 4:
                        sprites.judgeRealTime.judge.text = "Judge: S";
                        break;
                    case 5:
                        sprites.judgeRealTime.judge.text = "Judge: V";
                        break;
                    case 6:
                        sprites.judgeRealTime.judge.text = "Judge: Phi";
                        break;
                    default:
                        sprites.judgeRealTime.judge.text = "Judge: None"
                }
                sprites.judgeRealTime.acc.text = "Acc: " + this.acc + "%", sprites.judgeRealTime.perfect.text = "Perfect: " + this.perfect, sprites.judgeRealTime.good.text = "Good: " + this.good, sprites.judgeRealTime.bad.text = "Bad: " + this.bad, sprites.judgeRealTime.miss.text = "Miss: " + this.miss
            }
            return this
        }
    },
    fullscreen = { toggle(e, t = !1) { if (this.element) { if (!t) { if (document.exitFullscreen) return document.exitFullscreen(); if (document.cancelFullScreen) return document.cancelFullScreen(); if (document.webkitCancelFullScreen) return document.webkitCancelFullScreen(); if (document.mozCancelFullScreen) return document.mozCancelFullScreen(); if (document.msExitFullscreen) return document.msExitFullscreen() } return this.element == e ? (e.style.position = "relative", e.style.top = "unset", e.style.left = "unset", e.style.zIndex = "unset", document.body.style.overflow = "auto", document.inDocumentFullscreenElement = null, global.functions.resizeCanvas && global.functions.resizeCanvas(), !0) : !1 } if (!t) { if ((e = e instanceof HTMLElement ? e : document.body).requestFullscreen) return e.requestFullscreen(); if (e.webkitRequestFullscreen) return e.webkitRequestFullscreen(); if (e.mozRequestFullScreen) return e.mozRequestFullScreen(); if (e.msRequestFullscreen) return e.msRequestFullscreen() } return e != document.body && (e.style.position = "fixed", e.style.top = "0", e.style.left = "0", e.style.zIndex = "5050", document.body.style.overflow = "hidden", document.inDocumentFullscreenElement = e, global.functions.resizeCanvas && global.functions.resizeCanvas(), !0) }, check(e) { return e instanceof HTMLElement || (e = document.body), this.element == e }, get element() { return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || document.inDocumentFullscreenElement }, get enabled() { return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled) }, get type() { return document.inDocumentFullscreenElement ? 2 : document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement ? 1 : 0 } },
    specialClick = {
        clicks: [0, 0, 0, 0],
        functions: [() => { gamePause() }, () => { gameRestart() }, () => {}, () => { setCanvasFullscreen() }],
        click: function(e) {
            var t = Date.now();
            t - this.clicks[e] < 300 && this.functions[e](), this.clicks[e] = t
        }
    };

function setProgress(e, t, i = null) {
    let s = document.getElementById(e),
        n = s.getElementsByClassName("text")[0],
        r = s.getElementsByClassName("progress")[0];
    r = r.getElementsByTagName("div")[0], s && (n.innerHTML = t, null != i && 0 <= i ? (r.className = "mdui-progress-determinate", r.style.width = 100 * i + "%") : r.className = "mdui-progress-indeterminate", mdui.mutation(s))
}

function createSelection(e, i, s = null) {
    let n = document.getElementById(e);
    if (n.innerHTML = "", i instanceof Array)
        for (let t = 0; t < i.length; t++) {
            var r = i[t];
            let e = document.createElement("option");
            e.value = t, e.innerHTML = s ? r[s] : r, n.appendChild(e)
        } else if (i instanceof Object)
            for (var a in i) {
                let e = document.createElement("option");
                e.innerHTML = e.value = a, n.appendChild(e)
            }
}

function createMenuItems(e, s, n, t = null, r = null, a = null, o = null, l = null) {
    let d = document.getElementById(e),
        c = NaN,
        u = (d.innerHTML = "", document.createElement("div")),
        m = document.createElement("a");
    if (s instanceof Array)
        for (let i = 0; i < s.length; i++) {
            let e = s[i],
                t = "";
            0 != (r ? e[r] : e).indexOf(".") && (u = document.createElement("div"), m = document.createElement("a"), -1 == a && isNaN(c) || a == i ? (t = '<i class="mdui-menu-item-icon mdui-icon material-icons">&#xe5ca;</i>', c = i) : t = '<i class="mdui-menu-item-icon mdui-icon material-icons"></i>', t += r ? e[r] : e, m.setAttribute("onclick", "selectMenuItem('" + d.id.replace(/'/g, "'") + "', this" + (l ? ", '" + l + "'" : "") + ");" + n + " = '" + i + "'" + (o ? ";" + o : "")), m.setAttribute("menu-value", r ? e[r] : e), m.className = "mdui-ripple", u.className = "mdui-menu-item", m.innerHTML = t, u.appendChild(m), d.appendChild(u))
        } else if (s instanceof Object)
            for (var h in s) {
                let e = "";
                0 != h.indexOf(".") && (u = document.createElement("div"), m = document.createElement("a"), -1 == a && isNaN(c) || a == h ? (e = '<i class="mdui-menu-item-icon mdui-icon material-icons">&#xe5ca;</i>' + h, c = 0) : e = '<i class="mdui-menu-item-icon mdui-icon material-icons"></i>' + h, m.setAttribute("onclick", "selectMenuItem('" + d.id.replace(/'/g, "'") + "', this" + (l ? ", '" + l + "'" : "") + ");" + n + " = " + t + "['" + h.replace(/'/g, "'") + "']" + (o ? ";" + o : "")), m.setAttribute("menu-value", h), m.className = "mdui-ripple", u.className = "mdui-menu-item", m.innerHTML = e, u.appendChild(m), d.appendChild(u))
            }
    isNaN(c) || selectMenuItem(d.id, m, l), mdui.mutation(d)
}

function selectMenuItem(e, t, i = null) {
    let s = document.getElementById(e);
    var n;
    for (n of s.getElementsByClassName("mdui-menu-item")) {
        let e = n.getElementsByTagName("a")[0],
            t = e.getElementsByClassName("mdui-menu-item-icon")[0];
        t.innerHTML = ""
    }
    t.getElementsByClassName("mdui-menu-item-icon")[0].innerHTML = "&#xe5ca;", i && (document.getElementById(i).innerHTML = "当前选择了：" + t.getAttribute("menu-value"))
}

function BlurImage(e, t = 10) { var i = document.createElement("canvas"); let s = null; return s = e instanceof PIXI.BaseTexture ? e.resource.source : e, StackBlur.image(s, i, t), i }

function CalculateChartData(e) {
    let n = [],
        t = {},
        a = { hold: [], notHold: [], fakeNotes: [] };
    for (var r of e.judgeLineList) {
        let i = 0,
            s = { id: Number(n.length), bpm: r.bpm, speedEvents: [], judgeLineMoveEvents: [], judgeLineRotateEvents: [], judgeLineDisappearEvents: [], numOfNotes: r.numOfNotes, numOfNotesAbove: r.numOfNotesAbove, numOfNotesBelow: r.numOfNotesBelow };
        if (!(r.notesAbove.length <= 0 && r.notesBelow.length <= 0 && (!r.notesFakeAbove || r.notesFakeAbove.length <= 0) && (!r.notesFakeBelow || r.notesFakeBelow.length <= 0) && r.judgeLineMoveEvents.length <= 1 && r.judgeLineRotateEvents.length <= 1 && r.judgeLineDisappearEvents.length <= 1 && r.speedEvents.length <= 1)) {
            s.speedEvents = u(function(e) {
                let t = [];
                for (var i of e) {
                    let e = t[t.length - 1];
                    e && e.value == i.value ? e.endTime = i.endTime : t.push(i)
                }
                return JSON.parse(JSON.stringify(t))
            }(r.speedEvents), r.bpm), s.judgeLineMoveEvents = u(c(r.judgeLineMoveEvents), r.bpm), s.judgeLineRotateEvents = u(c(r.judgeLineRotateEvents), r.bpm), s.judgeLineDisappearEvents = u(c(r.judgeLineDisappearEvents), r.bpm);
            for (let e = 0; e < r.notesAbove.length; e++) d(r.notesAbove[e], s, a.hold.length + a.notHold.length, e, i, !0), i++;
            for (let t = 0; t < r.notesBelow.length; t++) d(r.notesBelow[t], s, a.hold.length + a.notHold.length, t, i, !1), i++;
            if (r.notesFakeAbove)
                for (let e = 0; e < r.notesFakeAbove.length; e++) d(r.notesFakeAbove[e], s, a.fakeNotes.length, e, i, !0), i++;
            if (r.notesFakeBelow)
                for (let e = 0; e < r.notesFakeBelow.length; e++) d(r.notesFakeBelow[e], s, a.fakeNotes.length, e, i, !1), i++;
            n.push(s)
        }
    }
    for (var i in a)
        for (var s of a[i]) t[s.realTime.toFixed(6)] = t[s.realTime.toFixed(6)] ? 2 : 1;
    for (var o in a)
        for (var l of a[o]) l.isMulti = 2 == t[l.realTime.toFixed(6)];
    return a.hold.sort(global.functions.sortNote), a.notHold.sort(global.functions.sortNote), a.fakeNotes.sort(global.functions.sortNote), { judgeLines: n, notes: a, offset: e.offset };

    function d(e, t, i, s, n, r) { e.type = Number(e.type), e.realTime = e.time * (1.875 / t.bpm), e.realHoldTime = e.holdTime * (1.875 / t.bpm), e.offsetY = e.floorPosition, e.holdLength = e.realHoldTime * e.speed, e.lineId = Number(t.id), e.id = Number(i), e.idToSide = Number(s), e.idToLine = Number(n), e.isAbove = r, e.isFake = e.isFake, e.score = 0, e.isScored = !1, e.isProcessed = !1, e.isPressing = !1, e.pressTime = 0, e.accType = 0, (e.isFake ? a.fakeNotes : 3 === e.type ? a.hold : a.notHold).push(e) }

    function c(e) {
        let t = JSON.parse(JSON.stringify(e)),
            i = [],
            s = [{ startTime: 1 - 1e6, endTime: 0, start: t[0] ? t[0].start : 0, end: t[0] ? t[0].end : 0, start2: t[0] ? t[0].start2 : 0, end2: t[0] ? t[0].end2 : 0 }];
        t.push({ startTime: 0, endTime: 1e9, start: t[t.length - 1] ? t[t.length - 1].start : 0, end: t[t.length - 1] ? t[t.length - 1].end : 0, start2: t[t.length - 1] ? t[t.length - 1].start2 : 0, end2: t[t.length - 1] ? t[t.length - 1].end2 : 0 });
        for (var n of t) {
            var r = s[s.length - 1];
            r.endTime > n.endTime || (r.endTime == n.startTime ? s.push(n) : r.endTime < n.startTime ? s.push({ startTime: r.endTime, endTime: n.startTime, start: r.end, end: r.end, start2: r.end2, end2: r.end2 }, n) : r.endTime > n.startTime && s.push({ startTime: r.endTime, endTime: n.endTime, start: (n.start * (n.endTime - r.endTime) + n.end * (r.endTime - n.startTime)) / (n.endTime - n.startTime), end: r.end, start2: (n.start2 * (n.endTime - r.endTime) + n.end2 * (r.endTime - n.startTime)) / (n.endTime - n.startTime), end2: r.end2 }))
        }
        i = [s.shift()];
        for (var a of s) {
            let e = i[i.length - 1];
            var o = e.endTime - e.startTime,
                l = a.endTime - a.startTime;
            a.startTime != a.endTime && (e.end == a.start && e.end2 == a.start2 && (e.end - e.start) * l == (a.end - a.start) * o && (e.end2 - e.start2) * l == (a.end2 - a.start2) * o ? (e.endTime = a.endTime, e.end = a.end, e.end2 = a.end2) : i.push(a))
        }
        return JSON.parse(JSON.stringify(i))
    }

    function u(e, t) { for (var i of e) i.startRealTime = i.startTime / t * 1.875, i.endRealTime = i.endTime / t * 1.875, i.startDeg = -Math.PI / 180 * i.start, i.endDeg = -Math.PI / 180 * i.end; return e }
}

function CreateChartSprites(e, r, i) {
    r.renderer.realWidth;
    let a = r.renderer.realHeight,
        o = r.renderer.fixedWidth;
    r.renderer.fixedWidthOffset;
    var s, t, n, l, d = r.renderer.lineScale;
    let c = r.renderer.noteScale,
        u = { judgeLines: [], notes: [], fakeNotes: [] };
    if (settings.background) {
        let e = new PIXI.Sprite(settings.backgroundBlur ? _chart.imageBlur : _chart.image);
        var m = o / _chart.image.width,
            h = a / _chart.image.height,
            m = h < m ? m : h;
        let t = new PIXI.Graphics;
        t.beginFill(0), t.drawRect(0, 0, e.width, e.height), t.endFill(), t.position.x = -e.width / 2, t.position.y = -e.height / 2, t.alpha = .5, e.addChild(t), e.anchor.set(.5), e.scale.set(m), e.position.set(o / 2, a / 2), u.background = e, i.addChild(e)
    }
    settings.spectrumSettings.enabled && (u.spectrumGraphics = new PIXI.Graphics, u.spectrumGraphics.position.y = a, i.addChild(u.spectrumGraphics));
    for (s of e.judgeLines) {
        let t = new PIXI.Sprite(textures.judgeLine);
        if (t.raw = s, t.anchor.set(.5), t.height = 18.75 * d * .008, t.width = t.height * t.texture.width / t.texture.height * 1.042, t.position.set(0, 0), t.zIndex = u.judgeLines.length + 1, settings.showApStatus && (t.tint = 16772256), settings.developMode) {
            let e = new PIXI.Text(s.id, { fill: "rgb(255,100,100)" });
            e.anchor.set(.5, 1), e.position.set(0), t.addChild(e)
        }
        t.position.x = o / 2, t.position.y = a / 2, u.judgeLines.push(t), i.addChild(t)
    }
    for (t of e.notes.fakeNotes) u.fakeNotes.push(g(t, i, 100 + u.notes.length + 1));
    for (n of e.notes.hold) u.notes.push(g(n, i, 100 + u.notes.length + 1));
    for (l of e.notes.notHold) u.notes.push(g(l, i, 100 + u.notes.length + 1));
    return u.notes.sort(global.functions.sortNote), u.fakeNotes.sort(global.functions.sortNote), u;

    function g(s, e = null, t = null) {
        let n = null;
        if (3 === s.type) {
            n = new PIXI.Container;
            let e = new PIXI.Sprite(textures["holdHead" + (s.isMulti && settings.multiNotesHighlight ? "Hl" : "")]),
                t = new PIXI.Sprite(textures["holdBody" + (s.isMulti && settings.multiNotesHighlight ? "Hl" : "")]),
                i = new PIXI.Sprite(textures["holdEnd" + (s.isMulti && settings.multiNotesHighlight ? "Hl" : "")]);
            e.anchor.set(.5), t.anchor.set(.5, 1), i.anchor.set(.5, 1), t.height = s.holdLength * r.renderer.noteSpeed / c, e.position.set(0, e.height / 2), t.position.set(0, 0), i.position.set(0, -t.height), n.addChild(e), n.addChild(t), n.addChild(i)
        } else(n = new PIXI.Sprite(textures.tap)).anchor.set(.5), 1 == s.type ? n.texture = textures["tap" + (s.isMulti && settings.multiNotesHighlight ? "Hl" : "")] : 2 == s.type ? n.texture = textures["drag" + (s.isMulti && settings.multiNotesHighlight ? "Hl" : "")] : 4 == s.type && (n.texture = textures["flick" + (s.isMulti && settings.multiNotesHighlight ? "Hl" : "")]);
        if (settings.developMode) {
            let e = new PIXI.Text(s.lineId + (s.isAbove ? "+" : "-") + s.id, { fill: "rgb(100,255,100)" });
            e.scale.set(1 / (r.renderer.width / settings.noteScale)), e.anchor.set(.5, 1), e.position.set(0), n.addChild(e)
        }
        return n.raw = s, n.scale.set(c), n.position.x = .109 * s.positionX.toFixed(6) * (o / 2) + o / 2, n.position.y = s.offsetY * (.6 * a) * (s.isAbove ? -1 : 1), isNaN(Number(t)) || (n.zIndex = t), s.isAbove || (n.angle = 180), e && e.addChild(n), n
    }
}

function CreateGameStartSprites(t, e, i, s) {
    i.renderer.realWidth;
    var n = i.renderer.realHeight,
        r = i.renderer.fixedWidth,
        a = i.renderer.lineScale;
    let o = e;
    if ((o = o || {}).container || (o.container = new PIXI.Container, s.addChild(o.container)), !o.songTitle) {
        let e = new PIXI.Text(t.name || "No Title", { fontFamily: "Mina", fill: "white", align: "center" });
        e.anchor.x = .5, o.container.addChild(e), o.songTitle = e
    }
    if (!o.bgAuthor) {
        let e = new PIXI.Text("Illustration designed by " + (t.illustrator || "No name"), { fontFamily: "Mina", fill: "white", align: "center" });
        e.anchor.set(.5, 1), o.container.addChild(e), o.bgAuthor = e
    }
    if (!o.chartAuthor) {
        let e = new PIXI.Text("Level designed by " + (_chart.info.designer || "No name"), { fontFamily: "Mina", fill: "white", align: "center" });
        e.anchor.set(.5, 1), o.container.addChild(e), o.chartAuthor = e
    }
    return o.fakeJudgeline || (o.fakeJudgeline = new PIXI.Sprite(textures.judgeLine), o.fakeJudgeline.anchor.set(.5), s.addChild(o.fakeJudgeline)), o.songTitle.style.fontSize = 1.1 * a + "px", o.bgAuthor.style.fontSize = .55 * a + "px", o.chartAuthor.style.fontSize = .55 * a + "px", o.fakeJudgeline.height = 18.75 * i.renderer.lineScale * .008, o.fakeJudgeline.offsetWidth = i.renderer.fixedWidth, o.songTitle.position.x = r / 2, o.songTitle.position.y = n / 2 * .75, o.bgAuthor.position.x = r / 2, o.bgAuthor.position.y = n / 2 * 1.25 + .15 * a, o.chartAuthor.position.x = r / 2, o.chartAuthor.position.y = n / 2 * 1.25 + a, o.fakeJudgeline.position.x = i.renderer.fixedWidth / 2, o.fakeJudgeline.position.y = i.renderer.realHeight / 2, o.container.alpha = 0, o
}

function CreateChartInfoSprites(e, t, s, i, n = !1, r = !1) {
    var a = s.renderer.realWidth,
        o = s.renderer.realHeight,
        l = s.renderer.fixedWidth,
        d = s.renderer.fixedWidthOffset,
        c = s.renderer.lineScale;
    let u = t;
    if ((u = u || {}).head || (u.head = { container: new PIXI.Container }, u.head.container.zIndex = 99999), u.head.container.parent || i.addChild(u.head.container), u.head.progressBar || (u.head.progressBar = new PIXI.Sprite(textures.progressBar), u.head.progressBar.anchor.x = 1, u.head.container.addChild(u.head.progressBar)), u.head.scoreText || (u.head.scoreText = new PIXI.Text("0000000", { fontFamily: "Mina", fill: "white" }), u.head.scoreText.anchor.x = 1, u.head.scoreText.anchor.y = .5, u.head.container.addChild(u.head.scoreText)), !u.head.comboText) {
        let e = new PIXI.Container,
            t = new PIXI.Text("0", { fontFamily: "Mina", fill: "white" }),
            i = new PIXI.Text("combo", { fontFamily: "Mina", fill: "white" });
        settings.autoPlay && (i.text = "Autoplay"), t.anchor.set(.5), i.anchor.set(.5, 1), e.addChild(t), e.addChild(i), u.head.container.addChild(e), u.head.comboText = e
    }
    if (u.foot || (u.foot = { container: new PIXI.Container }, u.foot.container.zIndex = 99999), u.foot.container.parent || i.addChild(u.foot.container), u.foot.songNameBar || (u.foot.songNameBar = new PIXI.Sprite(textures.songNameBar), u.foot.container.addChild(u.foot.songNameBar)), u.foot.songTitle || (u.foot.songTitle = new PIXI.Text(_chart.info.name || "No title", { fontFamily: "Mina", fill: "white", align: "center" }), u.foot.songTitle.anchor.y = 1, u.foot.container.addChild(u.foot.songTitle)), u.foot.songDiff || (u.foot.songDiff = new PIXI.Text(_chart.info.level || "SP Lv.?", { fontFamily: "Mina", fill: "white", align: "right" }), u.foot.songDiff.anchor.set(1), u.foot.container.addChild(u.foot.songDiff)), !u.backgroundCover) {
        let e = new PIXI.Sprite(settings.backgroundBlur ? _chart.imageBlur : _chart.image),
            t = new PIXI.Graphics,
            i = new PIXI.Container;
        t.position.set(-e.width / 2, -e.height / 2), t.alpha = .5, e.addChild(t), e.anchor.set(.5), e.zIndex = 999999, s.stage.addChild(e), i.addChild(new PIXI.Graphics, new PIXI.Graphics), e.mask = i, u.backgroundCover = { image: e, cover: i }
    }
    if (n && !u.fps) {
        let e = new PIXI.Text("00.00", { fontFamily: "Mina", fill: "rgba(255, 255, 255, 0.5)", align: "right" });
        e.anchor.set(1, 0), e.zIndex = 1e6, s.stage.addChild(e), u.fps = e, u.fpsInterval = setInterval(() => { e.text = s.ticker.FPS.toFixed(2) }, 200)
    }
    if (!u.watermark) {
        let e = new PIXI.Text("Ph1gr0s Emulator v0.1.11 Alpha By MisaLiu Origin By lchzh3473", { fontFamily: "Mina", fill: "rgba(255, 255, 255, 0.5)", align: "right" });
        e.anchor.set(1), e.zIndex = 1e6, s.stage.addChild(e), u.watermark = e
    }
    u.head.progressBar.scale.set(l / (textures.progressBar.width / s.renderer.resolution)), u.head.progressBar.height = 3, u.head.scoreText.style.fontSize = .95 * c + "px", u.head.comboText.children[0].style.fontSize = 1.32 * c + "px", u.head.comboText.children[1].style.fontSize = .66 * c + "px", u.foot.songNameBar.width = .119 * c, u.foot.songNameBar.height = .612 * c, u.foot.songTitle.style.fontSize = .63 * c + "px", u.foot.songDiff.style.fontSize = .63 * c + "px";
    var m = a / _chart.image.width,
        h = o / _chart.image.height;
    return u.backgroundCover.image.scale.set(h < m ? m : h), u.fps && (u.fps.style.fontSize = .8 * c + "px"), u.watermark.style.fontSize = .6 * c + "px", u.backgroundCover.image.visible = l < a, u.backgroundCover.image.children[0].clear(), u.backgroundCover.image.children[0].beginFill(0).drawRect(0, 0, u.backgroundCover.image.texture.baseTexture.width, u.backgroundCover.image.texture.baseTexture.height).endFill(), u.backgroundCover.cover.children[0].clear(), u.backgroundCover.cover.children[1].clear(), u.backgroundCover.cover.children[0].beginFill(16777215).drawRect(0, 0, d, o).endFill(), u.backgroundCover.cover.children[1].beginFill(16777215).drawRect(a - d, 0, d, o).endFill(), r || (u.head.comboText.alpha = 0, u.head.container.alpha = 0, u.foot.container.alpha = 0), u.head.scoreText.position.set(l - .65 * c, 1.375 * c), u.head.comboText.position.x = l / 2, u.head.comboText.children[0].position.y = 1.375 * c, u.head.comboText.children[1].position.y = 1.375 * c + u.head.comboText.children[0].height, u.foot.songNameBar.position.x = .53 * c, u.foot.songNameBar.position.y = o - 1.22 * c, u.foot.songTitle.position.x = .85 * c, u.foot.songTitle.position.y = o - .525 * c, u.foot.songDiff.position.x = l - .75 * c, u.foot.songDiff.position.y = o - .525 * c, u.backgroundCover.image.position.set(a / 2, o / 2), u.fps.position.set(a - 1, 1), u.watermark.position.set(a - 2, o - 2), r ? (u.head.container.position.y = 0, u.foot.container.position.y = 0) : (u.head.container.position.y = -u.head.container.height, u.foot.container.position.y = u.head.container.height), u
}

function CreateGameEndSprites(e, t, i, s = !1) {
    t.renderer.realWidth;
    var n = t.renderer.realHeight,
        r = t.renderer.fixedWidth,
        a = (t.renderer.fixedWidthOffset, t.renderer.lineScale),
        o = 27.621528 * a,
        l = 14.461806 * a,
        d = 1.111111 * a,
        c = 13.680556 * a,
        u = .399306 * a,
        m = c / _chart.image.width,
        h = c / _chart.image.height,
        m = h < m ? m : h;
    let g = e;
    switch (g || ((g = {}).container = new PIXI.Container, g.bgRect = new PIXI.Graphics, g.image = { image: new PIXI.Sprite, gradient: new PIXI.Graphics, cover: new PIXI.Graphics, songName: new PIXI.Text("", { fontFamily: "Mina", fill: "white" }), songDiff: new PIXI.Text("", { fontFamily: "Mina", fill: "white" }), retryBtn: new PIXI.Graphics }, g.judgeIcon = new PIXI.Sprite, g.newScore = new PIXI.Text("", { fontFamily: "Mina", fill: "white" }), g.score = new PIXI.Text("", { fontFamily: "Mina", fill: "white" }), g.judge = { container: new PIXI.Container, perfect: new PIXI.Text("", { fontFamily: "Mina", fill: "white" }), good: new PIXI.Text("", { fontFamily: "Mina", fill: "white" }), bad: new PIXI.Text("", { fontFamily: "Mina", fill: "white" }), miss: new PIXI.Text("", { fontFamily: "Mina", fill: "white" }) }, g.acc = { container: new PIXI.Container, percent: new PIXI.Text("", { fontFamily: "Mina", fill: "white" }), apType: new PIXI.Text("", { fontFamily: "Mina", fill: "white" }) }, g.container.addChild(g.bgRect), g.image.image.addChild(g.image.gradient), g.container.addChild(g.image.image, g.image.cover, g.image.songName, g.image.songDiff, g.image.retryBtn), g.container.addChild(g.judgeIcon), g.container.addChild(g.newScore), g.container.addChild(g.score), g.judge.container.addChild(g.judge.perfect, g.judge.good, g.judge.bad, g.judge.miss), g.container.addChild(g.judge.container), g.acc.container.addChild(g.acc.percent, g.acc.apType), g.container.addChild(g.acc.container), i.addChild(g.container)), g.image.image.texture = _chart.image, score.judge) {
        case 0:
            g.judgeIcon.texture = textures.judgeIcon.false;
            break;
        case 1:
            g.judgeIcon.texture = textures.judgeIcon.c;
            break;
        case 2:
            g.judgeIcon.texture = textures.judgeIcon.b;
            break;
        case 3:
            g.judgeIcon.texture = textures.judgeIcon.a;
            break;
        case 4:
            g.judgeIcon.texture = textures.judgeIcon.s;
            break;
        case 5:
            g.judgeIcon.texture = textures.judgeIcon.v;
            break;
        case 6:
            g.judgeIcon.texture = textures.judgeIcon.phi
    }
    return g.bgRect.clear(), g.bgRect.beginFill(16777215, .11).drawRoundedRect(0, 0, o, l, .78125 * a).endFill(), g.image.gradient.clear(), g.image.gradient.beginFill(0).drawRect(-g.image.image.width / 2, -27.5, g.image.image.width, 50).endFill(), g.image.cover.clear(), g.image.cover.beginFill(16777215).drawRoundedRect(0, 0, c, c, .520833 * a).endFill(), g.image.retryBtn.clear(), g.image.retryBtn.beginFill(0, .6).drawRoundedRect(0, 0, 3.802083 * a, 1.336806 * a, .347222 * a).endFill(), g.image.retryBtn.children[0] || (g.image.retryBtn.addChild(new PIXI.Text("重试", { fontFamily: "Mina", fill: "white" })), g.image.retryBtn.interactive = !0, g.image.retryBtn.buttonMode = !0, g.image.retryBtn.on("pointerdown", () => { gameRestart() })), g.image.songName.text = _chart.info.name || "No name", g.image.songDiff.text = _chart.info.level || "SP Lv.?", g.newScore.text = "Max combo: " + score.maxCombo, g.score.text = score.scoreText, g.judge.perfect.text = "Perfect " + score.perfect, g.judge.good.text = "Good " + score.good, g.judge.bad.text = "Bad " + score.bad, g.judge.miss.text = "Miss " + score.miss, g.acc.apType.text = 2 == score.apType ? "All Perfect" : 1 == score.apType ? "Full Combo" : "", g.acc.percent.text = score.acc + "%", g.image.songName.style.fontSize = .868056 * a + "px", g.image.songDiff.style.fontSize = .347222 * a + "px", g.image.retryBtn.children[0].style.fontSize = .520833 * a + "px", g.newScore.style.fontSize = .520833 * a + "px", g.score.style.fontSize = 1.736111 * a + "px", g.judge.perfect.style.fontSize = .347222 * a + "px", g.judge.good.style.fontSize = .347222 * a + "px", g.judge.bad.style.fontSize = .347222 * a + "px", g.judge.miss.style.fontSize = .347222 * a + "px", g.acc.percent.style.fontSize = .347222 * a + "px", g.acc.apType.style.fontSize = .520833 * a + "px", g.acc.apType.visible = 0 < score.apType, g.image.image.anchor.set(.5), g.image.image.scale.set(m), g.image.image.position.x = o - c + c / 2, g.image.image.position.y = l / 2, g.image.gradient.filters || (g.image.gradient.filters = [new PIXI.filters.BlurFilter(14, 4, PIXI.settings.FILTER_RESOLUTION, 9)]), g.image.gradient.scale.set(1 / m), g.image.gradient.position.y = g.image.image.texture.baseTexture.height / 2, g.image.cover.position.set(o - c - u, u), g.image.image.mask = g.image.cover, g.image.songName.position.x = 14.21875 * a, g.image.songName.position.y = 11.701389 * a, g.image.songName.width > c - 2 * (14.21875 * a - (o - c - u)) && (g.image.songName.width = c - 2 * (14.21875 * a - (o - c - u))), g.image.songDiff.position.x = 14.21875 * a, g.image.songDiff.position.y = 12.829861 * a, g.image.retryBtn.position.x = o - 3.802083 * a - 1.128472 * a, g.image.retryBtn.position.y = l - 1.336806 * a - .711806 * a, g.image.retryBtn.children[0].anchor.set(.5), g.image.retryBtn.children[0].position.x = 3.802083 * a / 2, g.image.retryBtn.children[0].position.y = 1.336806 * a / 2, g.judgeIcon.scale.set(4.930556 * a / g.judgeIcon.texture.baseTexture.width), g.judgeIcon.position.x = .295139 * a, g.judgeIcon.position.y = 1.979167 * a, g.newScore.position.x = d, g.newScore.position.y = 8.211806 * a, g.score.position.x = d, g.score.position.y = 8.854167 * a, g.judge.good.position.x = g.judge.perfect.width + .78125 * a, g.judge.bad.position.x = g.judge.good.position.x + g.judge.good.width + .78125 * a, g.judge.miss.position.x = g.judge.bad.position.x + g.judge.bad.width + .78125 * a, g.judge.container.position.x = d, g.judge.container.position.y = 11.041667 * a, g.acc.percent.anchor.y = g.acc.apType.visible ? 1 : 0, g.acc.percent.position.x = g.acc.apType.visible ? g.acc.apType.width + .416667 * a : 0, g.acc.percent.position.y = g.acc.apType.visible ? g.acc.apType.height : .138889 * a, g.acc.container.position.x = d, g.acc.container.position.y = g.judge.container.position.y + g.judge.container.height + 1.163194 * a, g.container.position.x = (r - g.container.width) / 2, g.container.position.y = (n - g.container.height) / 2, s || (g.container.position.x = r, g.judgeIcon.alpha = 0, g.newScore.alpha = 0, g.score.alpha = 0, g.judge.container.alpha = 0, g.acc.container.alpha = 0), g
}

function CreateGameEndAnimation(n, r) {
    function a() {
        let e = r.ui.end,
            t = r.ui.game.head,
            i = r.ui.game.foot;
        var s = 1.111111 * n.renderer.lineScale;
        if (5.4 <= l.time) l.stop(), n.ticker.remove(a), stat.isTransitionEnd = !0;
        else if (4.8 <= l.time) e.judgeIcon.alpha = (l.time - 4.8) / .6;
        else if (3.6 <= l.time)
            if (4.6 <= l.time ? (e.acc.container.alpha = (l.time - 4.6) / .2, e.acc.container.position.x = s + s * (1 - d.solve((l.time - 4.6) / .2))) : 4.4 <= l.time ? (e.judge.container.alpha = (l.time - 4.4) / .2, e.judge.container.position.x = s + s * (1 - d.solve((l.time - 4.4) / .2))) : 4.2 <= l.time && (e.newScore.alpha = (l.time - 4.2) / .2, e.newScore.position.x = s + s * (1 - d.solve((l.time - 4.2) / .2))), l.time < 4.2)
                for (l.time < 3.8 && (e.score.alpha = (l.time - 3.6) / .2, e.score.position.x = s + s * (1 - d.solve((l.time - 3.6) / .2))), e.score.text = (Number(score.score) * ((l.time - 3.6) / .6)).toFixed(0) + ""; e.score.text.length < 7;) e.score.text = "0" + e.score.text;
            else e.score.alpha = 1, e.score.text = score.scoreText, e.score.position.x = s;
        else 3 <= l.time ? (global.levelOverAudio || (global.levelOverAudio = o.play({ volume: settings.musicVolume })), e.container.position.x = n.renderer.fixedWidth - (n.renderer.fixedWidth + e.container.width) / 2 * d.solve((l.time - 3) / .6)) : .67 <= l.time ? (!0 === r.ui.start.fakeJudgeline.visible && (r.ui.start.fakeJudgeline.visible = !1), r.ui.end || (r.ui.end = CreateGameEndSprites(r.ui.end, n, r.mainContainer)), t.container.position.y = -t.container.height, i.container.position.y = t.container.height, t.container.alpha = 0, i.container.alpha = 0) : (t.container.position.y = -t.container.height * d.solve(l.time / .67), i.container.position.y = t.container.height * d.solve(l.time / .67), t.container.alpha = 1 - l.time / .67, i.container.alpha = 1 - l.time / .67, r.ui.start.fakeJudgeline.width = r.ui.start.fakeJudgeline.offsetWidth * (1 - d.solve(l.time / .67)), r.game.background.children[0].alpha = .5 + (1 - settings.backgroundDim - .5) * (1 - l.time / .67))
    }
    let o = null,
        l = new Timer,
        d = new Cubic(.19, .36, .48, 1.01);
    stat.isEnd = !0, r.ui.start.fakeJudgeline.visible = !0;
    for (var e of r.game.judgeLines) e.visible = !1;
    for (var t of r.game.notes) t.visible = !1;
    for (var i of r.game.fakeNotes) i.visible = !1; {
        let e = /^([a-zA-Z]+)\sLv\.(\d+|\?)$/,
            t = e.exec(_chart.info.level);
        switch (t = !t || t.length < 3 || !t[1] ? "in" : t[1].toLowerCase()) {
            case "ez":
                o = textures.sound.levelOver.ez;
                break;
            case "hd":
                o = textures.sound.levelOver.hd;
                break;
            case "in":
                o = textures.sound.levelOver.in;
                break;
            case "at":
                o = textures.sound.levelOver.at;
                break;
            case "sp":
                o = textures.sound.levelOver.sp;
                break;
            default:
                o = textures.sound.levelOver.in
        }
    }
    stat.isTransitionEnd = !1, l.start(), n.ticker.add(a)
}

function CalculateChartActualTime() {
    sprites.performanceIndicator && sprites.performanceIndicator.begin();
    var e, t, i, s, n, r, a, o, l, d = (global.audio ? _chart.audio.duration * global.audio.progress : 0) - _chart.data.offset - _chart.audio.baseLatency - settings.chartDelay,
        c = pixi.renderer.fixedWidth,
        u = pixi.renderer.realHeight,
        m = pixi.renderer.fixedWidthPercent,
        h = (pixi.renderer.fixedWidthOffset, pixi.renderer.noteSpeed),
        g = pixi.renderer.noteScale;
    pixi.renderer.resolution;
    let p = sprites.ui.game,
        f = p.head,
        v = (p.foot, sprites.game);
    f.progressBar.position.x = c * (global.audio ? global.audio.progress : 0);
    for (e of v.judgeLines) {
        if (!settings.disableJudgeLineAlpha)
            for (var b of e.raw.judgeLineDisappearEvents) {
                if (d < b.startRealTime) break;
                d > b.endRealTime || (t = (d - b.startRealTime) / (b.endRealTime - b.startRealTime), e.alpha = b.start * (1 - t) + b.end * t)
            }
        for (var x of e.raw.judgeLineMoveEvents) {
            if (d < x.startRealTime) break;
            d > x.endRealTime || (s = 1 - (i = (d - x.startRealTime) / (x.endRealTime - x.startRealTime)), e.position.x = c * (x.start * s + x.end * i), e.position.y = u * (1 - x.start2 * s - x.end2 * i))
        }
        for (const E of e.raw.judgeLineRotateEvents) {
            if (d < E.startRealTime) break;
            d > E.endRealTime || (n = (d - E.startRealTime) / (E.endRealTime - E.startRealTime), e.rotation = E.startDeg * (1 - n) + E.endDeg * n, e.cosr = Math.cos(e.rotation), e.sinr = Math.sin(e.rotation))
        }
        for (const A of e.raw.speedEvents) {
            if (d < A.startRealTime) break;
            d > A.endRealTime || (e.currentOffsetY = (d - A.startRealTime) * A.value + A.floorPosition)
        }
    }
    judgements.addJudgement(v.notes, d);
    for (r of v.notes)
        if (judgements.judgeSingleNote(r.raw, getNotePosition(r, !1), d, .117775 * c), !0 !== r.isProcessed)
            if (!0 === r.raw.isScored && !1 === r.isProcessed && 3 !== r.raw.type) r.visible = !1, r.isProcessed = !0;
            else {
                var w = d - r.raw.realTime,
                    T = v.judgeLines[r.raw.lineId];
                let e = r.raw;
                var y;
                T.raw;
                let t = e.positionX.toFixed(6) * m,
                    i = 0,
                    s, n;
                i = 3 != e.type || e.forceChangeSpeed ? (e.offsetY - T.currentOffsetY) * e.speed : e.realTime < d ? (e.realTime - d) * e.speed : e.offsetY - T.currentOffsetY, e.offsetY < T.currentOffsetY ? 3 === e.type ? 0 < (y = e.holdLength + e.offsetY - T.currentOffsetY) ? (!1 === r.visible && (r.visible = !0), !0 === r.children[0].visible && (r.children[0].visible = !1), r.children[1].height = y * h / g, r.children[2].position.y = -r.children[1].height, i = 0) : !0 === r.visible && (!0 === e.isScored && (r.isProcessed = !0), r.visible = !1) : w < 0 && !0 === r.visible && (r.visible = !1) : 3 === e.type && !1 === r.children[0].visible ? (r.children[0].visible = !0, r.children[1].height = e.holdLength * h / g, r.children[2].position.y = -r.children[1].height) : w < 0 && !1 === r.visible && (r.visible = !0), i = i * (e.isAbove ? -1 : 1) * h, s = t * T.cosr - i * T.sinr, n = i * T.cosr + t * T.sinr, r.position.x = s + T.position.x, r.position.y = n + T.position.y, r.angle = T.angle + (e.isAbove ? 0 : 180), 0 < w && (3 != e.type ? (r.alpha = 1 - w / global.judgeTimes.bad, w > global.judgeTimes.bad && (r.visible = !1, r.isProcessed = !0)) : 1 === e.score && .5 !== r.alpha && (r.alpha = .5))
            }
    for (a of v.fakeNotes)
        if (!0 !== a.isProcessed) {
            var I = d - a.raw.realTime,
                C = v.judgeLines[a.raw.lineId];
            let e = a.raw;
            var k;
            C.raw;
            let t = e.positionX.toFixed(6) * m,
                i = 0,
                s, n;
            i = 3 != e.type || e.forceChangeSpeed ? (e.offsetY - C.currentOffsetY) * e.speed : e.realTime < d ? (e.realTime - d) * e.speed : e.offsetY - C.currentOffsetY, e.offsetY < C.currentOffsetY ? 3 === e.type ? 0 < (k = e.holdLength + e.offsetY - C.currentOffsetY) ? (!1 === a.visible && (a.visible = !0), !0 === a.children[0].visible && (a.children[0].visible = !1), a.children[1].height = k * h / g, a.children[2].position.y = -a.children[1].height, i = 0) : !0 === a.visible && (a.visible = !1) : I < 0 && !0 === a.visible && (a.visible = !1) : 3 === e.type && !1 === a.children[0].visible ? (a.children[0].visible = !0, a.children[1].height = (e.holdLength + e.offsetY) * h / g, a.children[2].position.y = -a.children[1].height) : I < 0 && !1 === a.visible && (a.visible = !0), i = i * (e.isAbove ? -1 : 1) * h, s = t * C.cosr - i * C.sinr, n = i * C.cosr + t * C.sinr, a.position.x = s + C.position.x, a.position.y = n + C.position.y, a.angle = C.angle + (e.isAbove ? 0 : 180), 0 < I && (3 != e.type ? (a.alpha = 1 - I / global.judgeTimes.bad, I > global.judgeTimes.bad && (a.visible = !1)) : 1 === e.score && .5 !== a.alpha && (a.alpha = .5))
        }
    if (settings.spectrumSettings.enabled && global.audioAnalyser) {
        v.spectrumGraphics.clear(), global.audioAnalyser.getByteFrequencyData(global.audioAnalyser.dataArray);
        var P = .002 * c,
            j = c / global.audioAnalyser.bufferLength - P;
        let e = P / 2;
        var S = global.audioAnalyser.dataArray;
        for (let t = 0; t < global.audioAnalyser.bufferLength; t++) {
            var N = S[t] / 255;
            v.spectrumGraphics.beginFill(_chart.image.baseColor, (.75 * N + .25) * settings.spectrumSettings.alphaPercent).drawRect(e, 0, j, -N * u * settings.spectrumSettings.heightPercent).endFill(), e += j + P
        }
    } else settings.spectrumSettings.enabled && v.spectrumGraphics.clear();
    for (o in inputs.taps.length = 0, inputs.touches) inputs.touches[o] instanceof Click && inputs.touches[o].animate();
    for (l in inputs.mouse) inputs.mouse[l] instanceof Click && inputs.mouse[l].animate();
    global.audio && 1 == global.audio.progress && (pixi.ticker.remove(CalculateChartActualTime), CreateGameEndAnimation(pixi, sprites)), sprites.performanceIndicator && sprites.performanceIndicator.end()
}

function CalculateClickAnimateActualTime() {
    if (!stat.isPaused)
        for (var e in sprites.clickAnimate) {
            let i = sprites.clickAnimate[e];
            if (2 < i.type) {
                var s = (i = i.children[0]).currentFrame / i.totalFrames;
                for (let t = 1; t < i.parent.children.length; t++) {
                    let e = i.parent.children[t];
                    var n = 30 * (((.2078 * s - 1.6524) * s + 1.6399) * s + .4988),
                        r = e.distance * (9 * s / (8 * s + 1)) * .6;
                    e.clear(), e.beginFill(16777215).drawRect(-n / 2, -n / 2, n, n).endFill(), e.position.x = r * e.cosr - r * e.sinr, e.position.y = r * e.cosr + r * e.sinr, e.alpha = 1 - s
                }
                i.alpha = 1 - s, i.playing || (sprites.clickAnimate.splice(e, 1), i.parent.destroy())
            } else i.alpha = 1 - (Date.now() - i.time) / 500, Date.now() >= i.time + 500 && (i.destroy(), sprites.clickAnimate.splice(e, 1))
        }
}

function CreateClickAnimation(e, t, i, s, n = !1) {
    let r = void 0;
    pixi.renderer.fixedWidth;
    var a = pixi.renderer.noteScale;
    if (pixi && settings.clickAnimate && !(s <= 1)) {
        if (3 <= s) {
            let t = new PIXI.AnimatedSprite(textures.clickRaw);
            var o = 14.964;
            let i = [null, null, null, null];
            if ((r = new PIXI.Container).scale.set(5.6 * a), t.tint = 4 == s ? 16772256 : 11854335, t.anchor.set(.5), t.scale.set(256 / t.texture.baseTexture.width), t.loop = !1, r.addChild(t), !n)
                for (let e = 0; e < i.length; e++) i[e] = (new PIXI.Graphics).beginFill(16777215).drawRect(-o / 2, -o / 2, o, o).endFill(), i[e].tint = 4 == s ? 16772256 : 11854335, i[e].distance = 81 * Math.random() + 185, i[e].direction = Math.floor(360 * Math.random()), i[e].sinr = Math.sin(i[e].direction), i[e].cosr = Math.cos(i[e].direction), r.addChild(i[e])
        } else(r = new PIXI.Sprite(textures.tap2)).anchor.set(.5), r.scale.set(a), r.angle = i, r.tint = 7095107;
        r.zIndex = 9999, r.position.set(e, t), r.type = s, r.time = Date.now(), sprites.clickAnimate.push(r), sprites.mainContainer.addChild(r), 3 <= s && r.children[0].play()
    }
}

function PlayHitsound(e, t) {
    let i = null;
    if (e.hitsound) i = e.hitsound;
    else if (!i && 2 < e.score) switch (e.type) {
        case 1:
            i = textures.sound.tap;
            break;
        case 2:
            i = textures.sound.drag;
            break;
        case 3:
            i = textures.sound.tap;
            break;
        case 4:
            i = textures.sound.flick;
            break;
        default:
            i = textures.sound.tap
    }
    if (i) return i.play({ volume: t })
}

function ResizeChartSprites(e, t, i, s = 8e3) {
    var n, r = t <= i / 9 * 16 ? t : i / 9 * 16,
        a = (t - r) / 2,
        o = .75 * i < r ? i / 18.75 : r / 14.0625,
        l = r / s,
        d = .6 * i;
    if (e.mainContainer.position.x = a, e.game.background && (a = r / _chart.image.width, n = pixi.renderer.realHeight / _chart.image.height, e.game.background.scale.set(n < a ? a : n), e.game.background.position.set(r / 2, i / 2)), e.ui.start = CreateGameStartSprites(_chart.info, e.ui.start, pixi, e.mainContainer), e.ui.game = CreateChartInfoSprites(_chart.info, e.ui.game, pixi, e.mainContainer, !0, !0), e.ui.game.head.accIndicator && (e.ui.game.head.accIndicator.container.position.x = r / 2, e.ui.game.head.accIndicator.container.scale.set(r / e.ui.game.head.accIndicator.scale)), e.game.spectrumGraphics && (e.game.spectrumGraphics.position.y = i), e.game.judgeLines && e.game.notes && !(e.game.judgeLines.length <= 0 || e.game.notes.length <= 0)) {
        for (var c of e.game.judgeLines) c.height = 18.75 * o * .008, c.width = c.height * c.texture.width / c.texture.height * 1.042;
        for (var u of e.game.notes) 3 == u.raw.type && 3 === u.children.length && (u.children[1].height = u.raw.holdLength * d / l, u.children[2].position.y = -u.children[1].height), u.scale.set(l);
        for (var m of e.game.fakeNotes) 3 == m.raw.type && 3 === m.children.length && (m.children[1].height = m.raw.holdLength * d / l, m.children[2].position.y = -m.children[1].height), m.scale.set(l);
        e.ui.end && (e.ui.end = CreateGameEndSprites(e.ui.end, pixi, e.mainContainer, stat.isTransitionEnd))
    }
}

function CreateAccurateIndicator(e, t, i = 500, s = !1) {
    let r = new PIXI.Container,
        n = new PIXI.Graphics;
    return n.beginFill(16777215, .4), n.drawRect(0, 2, s ? 100 : 200, 16), n.endFill(), n.beginFill(9306112, .8), n.drawRect(0, 6, s ? 10 : 20, 8), n.endFill(), n.beginFill(11854335, .8), n.drawRect(s ? 10 : 20, 6, s ? 20 : 40, 8), n.endFill(), n.beginFill(16772256, .8), n.drawRect(s ? 30 : 60, 6, s ? 40 : 80, 8), n.endFill(), n.beginFill(11854335, .8), n.drawRect(s ? 70 : 140, 6, s ? 20 : 40, 8), n.endFill(), n.beginFill(9306112, .8), n.drawRect(s ? 90 : 180, 6, s ? 10 : 20, 8), n.endFill(), n.beginFill(16777215, .8), n.drawRect(s ? 49 : 99, 0, 2, 20), n.endFill(), r.addChild(n), n.position.x = -n.width / 2, r.scale.set(e.renderer.realWidth / i), r.position.x = e.renderer.realWidth / 2, t.addChild(r), e.ticker.add(() => {
        if (1 < r.children.length)
            for (let t = 1, e = r.children.length; t < e; t++) {
                let e = r.children[t];
                e && (e.alpha = 1 - (Date.now() - e.time) / 2e3, Date.now() >= e.time + 2e3 && e.destroy())
            }
    }), {
        container: r,
        scale: i,
        pushAccurate: function(e, t) {
            new PIXI.Container;
            let i = new PIXI.Graphics,
                s = t - e,
                n = 0 < s ? s : -s;
            n < global.judgeTimes.perfect ? n = 16772256 : n < global.judgeTimes.good ? n = 11854335 : n < global.judgeTimes.bad && (n = 9306112);
            return i.beginFill(n), i.drawRect(0, 0, 2, 20), i.endFill(), i.position.x = 1e3 * s / 2, i.time = Date.now(), r.addChild(i), i
        }
    }
}

function DrawInputPoint(e, t, i, s, n = 0) {
    let r = sprites.inputs[i],
        a = r ? r[s] : null;
    if (settings.showFinger) return a ? a.visible || (a.scale.set(.08 * pixi.renderer.lineScale), a.visible = !0) : ((a = new PIXI.Graphics).beginFill(16777215), a.drawCircle(0, 0, 6), a.endFill(), a.scale.set(.08 * pixi.renderer.lineScale), pixi.stage.addChild(a), r[s] = a, sprites.inputs[i] = r), a.position.set(e, t), 0 == n ? a.tint = 65535 : 1 == n ? a.tint = 16776960 : 2 == n && (a.tint = 16711935), a
}

function getNotePosition(e, t = 0) {
    let i = e.raw,
        s = sprites.game.judgeLines[i.lineId];
    if (!i || !s) return { x: NaN, y: NaN, angle: NaN, sinr: NaN, cosr: NaN };
    var n = s.cosr,
        r = s.sinr,
        a = s.position.x,
        o = s.position.y;
    return { x: i.positionX.toFixed(6) * pixi.renderer.fixedWidthPercent * n + a + pixi.renderer.fixedWidthOffset, y: i.positionX.toFixed(6) * pixi.renderer.fixedWidthPercent * r + o, angle: s.angle, sinr: r, cosr: n }
}
var panelInst = new mdui.Panel("#panel"),
    drawerInst = new mdui.Drawer("#drawer"),
    pixi = null,
    Loader = new PIXI.Loader,
    sprites = {},
    textures = { judgeIcon: {}, sound: { levelOver: {} } },
    _chart = {},
    chartData = { images: void 0, imagesBlur: void 0, audios: void 0, charts: void 0, infos: void 0, lines: void 0 },
    inputs = { taps: [], touches: {}, mouse: {}, isMouseDown: {}, keyboard: {} },
    stat = { isRetrying: !1, isTransitionEnd: !1, isPaused: !1, isFullscreen: !1 },
    judgements = new Judgements;
const judgementTimes = { bad: 200, good: 160, perfect: 80, badChallenge: 100, goodChallenge: 75, perfectChallenge: 40 };
Loader.onProgress.add(function(e, t) { setProgress("loading-sources", "正在加载资源：" + t.url + "...", e.progress / 100) }); { let e = document.getElementById("drawer").getElementsByClassName("mdui-list-item"); for (let t of e) t.addEventListener("click", e => {!drawerInst.isDesktop() && drawerInst.isOpen() && drawerInst.close() }) }

function selectZip() {
    let e = document.getElementById("input-select-chart"),
        t = document.getElementById("button-select-chart-zip");
    e.click(), e.onchange = function() { this.files && 1 == this.files.length && (t.innerHTML = "当前文件：" + this.files[0].name, decodeZip(this.files[0])) }
}

function decodeZip(t) {
    let i = new FileReader,
        s = new JSZip;
    i.onprogress = e => { setProgress("loading-chart-zip", "正在读取谱面包...", e.loaded / t.size) }, i.onloadend = e => {
        setProgress("loading-chart-zip", "谱面包读取完成！", 1), s.loadAsync(i.result).then(e => async function(i) {
            const e = "jpeg,jpg,gif,png,webp".split(","),
                t = "aac,flac,mp3,ogg,wav,webm".split(",");
            let n = 0,
                r = [];
            for (var s in chartData) chartData[s] = {};
            for (var a in i.files) {
                let e = i.files[a],
                    t = a.split("/");
                a = "";
                t = t[t.length - 1], a = h(t), e.dir || (e.realName = t, e.format = a, e.isHidden = 0 == t.indexOf("."), r.push(e))
            }
            for (var o of r) {
                let s = o.format;
                if (setProgress("loading-decode-chart", "正在解析文件：" + o.name + "...", n / r.length), "info.csv" == o.name) {
                    var l = Csv2Array(await o.async("text"), !0);
                    chartData.infos = JSON.parse(JSON.stringify(l))
                } else if ("line.csv" == o.name) {
                    l = Csv2Array(await o.async("text"), !0);
                    chartData.lines = l
                } else if (-1 !== e.indexOf(s.toLowerCase())) try {
                    let e = new ColorThief,
                        t = await PIXI.Texture.fromURL("data:image/" + s + ";base64," + await o.async("base64")),
                        i = PIXI.Texture.from(BlurImage(t.baseTexture, 20));
                    for (var d of e.getPalette(t.baseTexture.resource.source, 10))
                        if (.299 * d[0] + .587 * d[1] + .114 * d[2] < 192) { textures.baseColor = i.baseColor = Number("0x" + d[0].toString(16) + d[1].toString(16) + d[2].toString(16)); break }
                    t.baseColor || (t.baseColor = e.getColor(t.baseTexture.resource.source), t.baseColor = i.baseColor = Number("0x" + t.baseColor[0].toString(16) + t.baseColor[1].toString(16) + t.baseColor[2].toString(16))), chartData.images[o.name] = t, chartData.imagesBlur[o.name] = i
                } catch (i) { console.warn('"' + o.name + '" 可能不是一个有效的图像文件，将不会加载该文件。', i) } else if (-1 !== t.indexOf(s.toLowerCase())) try {
                    var c = PIXI.sound.Sound.from({ source: await o.async("arraybuffer"), preload: !0 });
                    chartData.audios[o.name] = c
                } catch (i) { console.warn('"' + o.name + '" 可能不是一个有效的音频文件，将不会加载该文件。', i) } else if ("json" === s) try {
                        var u = await o.async("text");
                        u = await CalculateChartData(u = await ConvertChartVersion(JSON.parse(u))), chartData.charts[o.name] = u
                    } catch (i) { console.warn('"' + o.name + '" 可能不是一个有效的谱面文件，将不会加载该文件。', i) } else if ("pec" === s) try {
                        var m;
                        m = await CalculateChartData(m = await ConvertChartVersion(await ConvertPEC2Json(m = await o.async("text"), o.name))), chartData.charts[o.name] = m
                    } catch (i) { console.warn('"' + o.name + '" 可能不是一个有效的谱面文件，将不会加载该文件。', i) } else console.warn('"' + o.name + '" 是一个不支持的文件，将不会加载该文件。');
                n++
            }
            createMenuItems("menu-chart-file", chartData.charts, "_chart.data", "chartData.charts", null, -1, "switchChart(this.getAttribute('menu-value'))", "list-text-chart-file"), createMenuItems("menu-chart-audio", chartData.audios, "_chart.audio", "chartData.audios", null, null, null, "list-text-chart-audio"), createMenuItems("menu-chart-image", chartData.images, "_chart.image", "chartData.images", null, null, "_chart.imageBlur = chartData.imagesBlur[this.getAttribute('menu-value')]", "list-text-chart-image"); {
                let e = document.getElementById("menu-chart-file").getElementsByTagName("a");
                switchChart(e[e.length - 1].getAttribute("menu-value"))
            }
            setProgress("loading-decode-chart", "全部文件解析完毕！", 1), setTimeout(() => { panelInst.closeAll(), panelInst.open(2) }, 500)
        }(e)).catch(e => { console.error('"' + t.name + '" 可能不是一个有效的 zip 文件。', e) })
    };
    try { if ("zip" != h(t.name)) return mdui.alert("这不是一个 *.zip 后缀的文件！<br>请确认您选择的是正确的文件格式。", "前方高能"), !1 } catch (e) {}

    function h(e) { var t = e.split("."); return t[t.length - 1] }
    i.readAsArrayBuffer(t), mdui.$("#loading-chart-group").removeClass("mdui-hidden")
}

function switchChart(n) {
    var r = chartData.infos;
    if (r) {
        let s = {};
        try {
            for (var e of r) {
                var t, i = JSON.parse(JSON.stringify(e)),
                    a = document.getElementById("menu-chart-audio").getElementsByTagName("a"),
                    o = document.getElementById("menu-chart-image").getElementsByTagName("a");
                for (t in i)
                    if (0 <= t.indexOf("Chart") && i[t] == n) {
                        if (s = { info: { name: i.Name, level: i.Level, illustrator: i.Illustrator, designer: i.Designer }, data: chartData.charts[n], audio: chartData.audios[i.Music], image: chartData.images[i.Image], imageBlur: chartData.imagesBlur[i.Image], lines: [] }, chartData.lines instanceof Array)
                            for (var l of chartData.lines) l.Chart == i.Chart && s.lines.push(l);
                        for (var d of a)
                            if (d.getAttribute("menu-value") == i.Music) { selectMenuItem("menu-chart-audio", d, "list-text-chart-audio"); break }
                        for (var c of o)
                            if (c.getAttribute("menu-value") == i.Image) { selectMenuItem("menu-chart-image", c, "list-text-chart-image"); break }
                        return mdui.$("#input-chart-name").val(i.Name), mdui.$("#input-chart-difficulty").val(i.Level), mdui.$("#input-chart-author").val(i.Designer), mdui.$("#input-chart-bg-author").val(i.Illustrator), mdui.mutation("#panel-select-chart-info"), void(_chart = s)
                    }
            }
        } catch (e) {
            console.warn("该谱面包可能不自带谱面信息，您可能需要手动填写相关信息。", e);
            let t = document.getElementById("menu-chart-image").getElementsByTagName("a")[0],
                i = document.getElementById("menu-chart-audio").getElementsByTagName("a")[0];
            var r = t.getAttribute("menu-value"),
                u = i.getAttribute("menu-value");
            if (s = { info: { name: null, level: null, illustrator: null, designer: null }, data: chartData.charts[n], audio: chartData.audios[u], image: chartData.images[r], imageBlur: chartData.imagesBlur[r], lines: [] }, chartData.lines instanceof Array)
                for (var m of chartData.lines) m.Chart == n && s.lines.push(m);
            return selectMenuItem("menu-chart-audio", i, "list-text-chart-audio"), selectMenuItem("menu-chart-image", t, "list-text-chart-image"), void(_chart = s)
        }
    }
}

function switchPanel(e) { panelInst.closeAll(), panelInst.open(e) }

function openMenu(e, t) {
    let i = document.getElementById(t),
        s = new mdui.Menu(e, i, { align: "right" });
    i.style.width = (320 < e.clientWidth - 72 ? 320 : e.clientWidth - 72) + "px", s.toggle()
}

function gameInit() {
    let t = document.getElementById("game-canvas-box");
    if (_chart.data)
        if (_chart.audio && _chart.audio.isLoaded)
            if (pixi) mdui.alert("模拟器已经启动啦！", "前方高能", () => { switchPanel(6) });
            else {
                global.judgeTimes = { perfect: (settings.challengeMode ? judgementTimes.perfectChallenge : judgementTimes.perfect) / 1e3, good: (settings.challengeMode ? judgementTimes.goodChallenge : judgementTimes.good) / 1e3, bad: (settings.challengeMode ? judgementTimes.badChallenge : judgementTimes.bad) / 1e3 }, switchPanel(6), pixi = new PIXI.Application({ width: t.offsetWidth, height: t.offsetWidth * (1 / settings.windowRatio), antialias: settings.antiAlias, autoDensity: !0, resolution: settings.resolution, forceCanvas: settings.forceCanvas }), t.innerHTML = "", t.appendChild(pixi.view), pixi.renderer.realWidth = pixi.renderer.width / pixi.renderer.resolution, pixi.renderer.realHeight = pixi.renderer.height / pixi.renderer.resolution, pixi.renderer.fixedWidth = pixi.renderer.realWidth <= pixi.renderer.realHeight / 9 * 16 ? pixi.renderer.realWidth : pixi.renderer.realHeight / 9 * 16, pixi.renderer.fixedWidthPercent = pixi.renderer.fixedWidth / 18, pixi.renderer.fixedWidthOffset = (pixi.renderer.realWidth - pixi.renderer.fixedWidth) / 2, pixi.renderer.noteSpeed = .6 * pixi.renderer.realHeight, pixi.renderer.noteScale = pixi.renderer.fixedWidth / settings.noteScale, pixi.renderer.lineScale = pixi.renderer.fixedWidth > .75 * pixi.renderer.realHeight ? pixi.renderer.realHeight / 18.75 : pixi.renderer.fixedWidth / 14.0625;
                let e = !(pixi.stage.sortableChildren = !0);
                try { pixi.view.addEventListener("test", null, Object.defineProperty({}, "passive", { get: function() { e = { passive: !1 } } })) } catch (e) {}
                if (window.addEventListener("resize", () => { global.functions.resizeCanvas(pixi) }), pixi.view.addEventListener("touchstart", e => {
                        e.preventDefault();
                        for (var t of e.changedTouches) {
                            var i = t.identifier,
                                t = s(t);
                            inputs.touches[i] = Click.activate(t.x, t.y, "touches", i)
                        }
                    }, e), pixi.view.addEventListener("touchmove", e => {
                        e.preventDefault();
                        for (var t of e.changedTouches) {
                            var i = t.identifier,
                                t = s(t);
                            inputs.touches[i].move(t.x, t.y)
                        }
                    }, e), pixi.view.addEventListener("touchend", e => {
                        e.preventDefault();
                        for (var t of e.changedTouches) {
                            t = t.identifier;
                            delete inputs.touches[t], settings.showFinger && sprites.inputs.touches[t] && (sprites.inputs.touches[t].visible = !1)
                        }
                    }, e), pixi.view.addEventListener("touchcancel", e => {
                        e.preventDefault();
                        for (var t of e.changedTouches) {
                            t = t.identifier;
                            delete inputs.touches[t], settings.showFinger && sprites.inputs.touches[t] && (sprites.inputs.touches[t].visible = !1)
                        }
                    }, e), pixi.view.addEventListener("mousedown", e => {
                        e.preventDefault();
                        var t = e.button,
                            i = s(e);
                        inputs.mouse[t] = Click.activate(i.x, i.y, "mouse", t), inputs.isMouseDown[t] = !0
                    }, e), pixi.view.addEventListener("mousemove", e => {
                        for (var t in e.preventDefault(), inputs.isMouseDown) {
                            var i;
                            inputs.isMouseDown[t] && (i = s(e), inputs.mouse[t].move(i.x, i.y))
                        }
                    }, e), pixi.view.addEventListener("mouseup", e => {
                        e.preventDefault();
                        var t = e.button;
                        delete inputs.mouse[t], delete inputs.isMouseDown[t], settings.showFinger && sprites.inputs.mouse[t] && (sprites.inputs.mouse[t].visible = !1)
                    }, e), pixi.view.addEventListener("mouseout", e => { for (var t in e.preventDefault(), inputs.mouse) inputs.isMouseDown[t] && (delete inputs.mouse[t], delete inputs.isMouseDown[t], settings.showFinger && sprites.inputs.mouse[t] && (sprites.inputs.mouse[t].visible = !1)) }, e), (sprites = { mainContainer: new PIXI.Container, mainContainerBlur: new PIXI.filters.BlurFilter, inputs: { touches: {}, mouse: {} }, clickAnimate: [], ui: {} }).mainContainerBlur.blur = 4, sprites.mainContainerBlur.repeatEdgePixels = !0, sprites.mainContainerBlur.padding = 1, sprites.mainContainer.filters = [sprites.mainContainerBlur], sprites.mainContainer.sortableChildren = !0, sprites.mainContainer.position.x = pixi.renderer.fixedWidthOffset, sprites.game = CreateChartSprites(_chart.data, pixi, sprites.mainContainer), sprites.ui.start = CreateGameStartSprites(_chart.info, sprites.ui.start, pixi, sprites.mainContainer), sprites.ui.game = CreateChartInfoSprites(_chart.info, sprites.ui.game, pixi, sprites.mainContainer, !0), settings.accIndicator && (sprites.ui.game.head.accIndicator = CreateAccurateIndicator(pixi, sprites.ui.game.head.container, settings.accIndicatorScale, settings.challengeMode)), score.init(sprites.game.notes.length, settings.challengeMode), settings.showJudgementRealTime) {
                    let e = { container: new PIXI.Container, judge: new PIXI.Text("Judge: False", { fill: "white", fontSize: 8 }), acc: new PIXI.Text("Acc: 0%", { fill: "white", fontSize: 8 }), perfect: new PIXI.Text("Perfect: 0", { fill: "white", fontSize: 8 }), good: new PIXI.Text("Good: 0", { fill: "white", fontSize: 8 }), bad: new PIXI.Text("Bad: 0", { fill: "white", fontSize: 8 }), miss: new PIXI.Text("Miss: 0", { fill: "white", fontSize: 8 }) };
                    e.container.zIndex = 1e6, e.container.addChild(e.judge, e.acc, e.perfect, e.good, e.bad, e.miss), e.acc.position.y = e.judge.height, e.perfect.position.y = e.acc.position.y + e.acc.height, e.good.position.y = e.perfect.position.y + e.perfect.height, e.bad.position.y = e.good.position.y + e.good.height, e.miss.position.y = e.bad.position.y + e.bad.height, e.container.position.set(8), pixi.stage.addChild(e.container), sprites.judgeRealTime = e
                }

                function s(e) { let t = { x: 0, y: 0 }; return fullscreen.check(pixi.view) ? (t.x = e.clientX, t.y = e.clientY) : (t.x = e.pageX - pixi.view.offsetLeft, t.y = e.pageY - pixi.view.offsetTop), t }
                sprites.mainContainer.sortChildren(), pixi.stage.addChild(sprites.mainContainer), pixi.stage.sortChildren(), _chart.audio.baseLatency = _chart.audio.context.audioContext.baseLatency || 0, gameStart(1e3), settings.showPerformanceIndicator && !sprites.performanceIndicator && (sprites.performanceIndicator = new Stats, sprites.performanceIndicator.showPanel(1), document.body.appendChild(sprites.performanceIndicator.dom), sprites.performanceIndicator.dom.style.position = "fixed", sprites.performanceIndicator.dom.style.top = "0px", sprites.performanceIndicator.dom.style.left = "unset", sprites.performanceIndicator.dom.style.right = "0px")
            }
    else mdui.alert("谱面音频正在努力装载中，请稍等一会再试！<br>如果你持续收到该消息，请检查音频文件。", "前方高能");
    else mdui.alert("你还没有选择一个谱面，请选择一个谱面！", "前方高能", () => { switchPanel(2) })
}

function gameStart(e = 1e3) {
    async function a() {
        let e = sprites.ui.start,
            t = sprites.ui.game.head,
            i = sprites.ui.game.foot;
        if (o.time < .67) t.container.position.y = -t.container.height * l.solve(1 - o.time / .67), t.container.alpha = o.time / .67, i.container.position.y = t.container.height * l.solve(1 - o.time / .67), i.container.alpha = o.time / .67, e.container.alpha = o.time / .67, e.fakeJudgeline.width = e.fakeJudgeline.offsetWidth * l.solve(o.time / .67), sprites.game.background.children[0].alpha = .5 + (1 - settings.backgroundDim - .5) * (o.time / .67);
        else if (.67 <= o.time && o.time < 5.33) {
            if (!0 === e.fakeJudgeline.visible) {
                e.fakeJudgeline.visible = !1;
                for (var s of sprites.game.judgeLines) s.visible = !0;
                for (var n of sprites.game.notes) n.visible = !0;
                for (var r of sprites.game.fakeNotes) r.visible = !0;
                pixi.ticker.add(CalculateChartActualTime), settings.clickAnimate && pixi.ticker.add(CalculateClickAnimateActualTime)
            }
            t.container.position.y = 0, t.container.alpha = 1, i.container.position.y = 0, i.container.alpha = 1, sprites.ui.start.container.alpha = 1
        } else 5.33 <= o.time && o.time < 6 ? sprites.ui.start.container.alpha = 1 - (o.time - 5.33) / .67 : 6 <= o.time && (sprites.ui.start.container.visible = !1, stat.isTransitionEnd = !0, stat.isRetrying = !1, o.stop(), global.audio = await _chart.audio.play({ start: 0, volume: settings.musicVolume }), global.audioAnalyser = _chart.audio.media.nodes.analyser, global.audioAnalyser.fftSize = 256, global.audioAnalyser.bufferLength = global.audioAnalyser.frequencyBinCount, global.audioAnalyser.dataArray = new Uint8Array(global.audioAnalyser.bufferLength), stat.isPaused && _chart.audio.pause(), pixi.ticker.remove(a))
    }
    let o = new Timer,
        l = new Cubic(.19, .36, .48, 1.01);
    sprites.mainContainerBlur.enabled = !1, sprites.game.background.children[0].alpha = .5, sprites.ui.game.head.progressBar.position.x = 0, sprites.ui.start.fakeJudgeline.tint = settings.showApStatus ? 16772256 : 16777215, sprites.ui.start.fakeJudgeline.visible = !0, sprites.ui.start.fakeJudgeline.width = 0;
    for (var t of sprites.game.judgeLines) t.visible = !1;
    for (var i of sprites.game.notes) i.visible = !1, i.isProcessed = !1;
    for (var s of sprites.game.fakeNotes) s.visible = !1;
    for (var n in sprites.ui.start.container.visible = !0, setTimeout(() => { stat.isEnd = !1, stat.isTransitionEnd = !1, o.start(), pixi.ticker.add(a) }, e), textures.sound) "levelOver" !== n && textures.sound[n].play({ volume: 0 });
    document.getElementById("game-btn-pause").innerHTML = '<i class="mdui-icon material-icons">&#xe034;</i> 暂停'
}

function setCanvasFullscreen(e = !1) { pixi && pixi.view && (stat.isFullscreen = !0, fullscreen.toggle(pixi.view, !!e || (!fullscreen.enabled || 2 == fullscreen.type))) }

function gamePause() {
    if (pixi && _chart.audio && !stat.isEnd)
        if (stat.isPaused) {
            global.audio = _chart.audio.play({ start: _chart.audio.duration * global.audio.progress, volume: settings.musicVolume }), sprites.ui.game.head.comboText.children[1].text = settings.autoPlay ? "Autoplay" : "combo", stat.isPaused = !1;
            for (var e of sprites.clickAnimate) e.children[0].play();
            sprites.mainContainerBlur.enabled = !1, document.getElementById("game-btn-pause").innerHTML = '<i class="mdui-icon material-icons">&#xe034;</i> 暂停'
        } else {
            _chart.audio.pause(), sprites.ui.game.head.comboText.children[1].text = "Paused", stat.isPaused = !0;
            for (var t of sprites.clickAnimate) t.children[0].stop();
            sprites.mainContainerBlur.enabled = !0, document.getElementById("game-btn-pause").innerHTML = '<i class="mdui-icon material-icons">&#xe037;</i> 继续'
        }
}

function gameRestart() {
    if (pixi && stat.isTransitionEnd && !stat.isRetrying) {
        stat.isRetrying = !0;
        pixi.renderer.fixedWidth, pixi.renderer.fixedWidthOffset;
        var e, t, i, s, n = pixi.renderer.noteSpeed,
            r = pixi.renderer.noteScale;
        pixi.renderer.resolution;
        stat.isPaused = !1, _chart.audio.stop(), global.audio = null, global.levelOverAudio && (global.levelOverAudio.stop(), global.levelOverAudio.destroy(), global.levelOverAudio = null), pixi.ticker.remove(CalculateChartActualTime), pixi.ticker.remove(CalculateClickAnimateActualTime), sprites.ui.end && (sprites.ui.end.container.destroy(), sprites.ui.end = null);
        for (e of sprites.clickAnimate) e.destroy();
        sprites.clickAnimate.length = 0;
        for (t of sprites.game.judgeLines) t.angle = 0, t.alpha = 1, t.currentOffsetY = 0, t.tint = settings.showApStatus ? 16772256 : 16777215, t.position.set(pixi.renderer.fixedWidth / 2, pixi.renderer.realHeight / 2);
        for (i of sprites.game.notes) i.raw.score = 0, i.raw.accType = 0, i.raw.isScored = !1, i.raw.isPressing = !1, i.raw.pressTime = null, i.alpha = 1, 3 == i.raw.type && (i.children[0].visible = !0, i.children[1].position.y = 0, i.children[1].height = i.raw.holdLength * n / r, i.children[2].position.y = -i.children[1].height);
        for (s of sprites.game.fakeNotes) s.alpha = 1, 3 == s.raw.type && (s.children[0].visible = !0, s.children[1].position.y = 0, s.children[1].height = s.raw.holdLength * n / r, s.children[2].position.y = -s.children[1].height);
        sprites.ui.game.head.container.position.y = -sprites.ui.game.head.container.height, sprites.ui.game.foot.container.position.y = sprites.ui.game.head.container.height, sprites.ui.game.head.comboText.alpha = 0, sprites.ui.game.head.comboText.children[0].text = "0", sprites.ui.game.head.comboText.children[1].text = settings.autoPlay ? "Autoplay" : "combo", sprites.ui.game.head.scoreText.text = "0000000", judgements.length = 0, score.init(sprites.game.notes.length, settings.challengeMode), _chart.audio.baseLatency = _chart.audio.context.audioContext.baseLatency || 0, global.baseAudioLatency = _chart.audio.context.audioContext.baseLatency || 0, gameStart(200)
    }
}

function gameDestroy() {
    pixi && sprites.mainContainer && stat.isTransitionEnd && mdui.confirm("你真的要这么做吗？", "前方高能！", () => {
        clearInterval(sprites.ui.game.fpsInterval), judgements.length = 0, stat.isTransitionEnd = !0, stat.isEnd = !1, stat.isPaused = !1, global.audio && (global.audio.stop(), global.audio = null), global.levelOverAudio && (global.levelOverAudio.stop(), global.levelOverAudio.destroy(), global.levelOverAudio = null);
        for (var e of sprites.game.notes) e.raw.score = 0, e.raw.isScored = !1, e.raw.isProcessed = !1, e.raw.isPressing = !1, e.raw.pressTime = null;
        sprites = { performanceIndicator: sprites.performanceIndicator }, inputs = { taps: [], touches: {}, mouse: {}, isMouseDown: {}, keyboard: {} }, pixi.destroy(!0, { children: !0 }), pixi = null, window.onresize = null, document.getElementById("game-canvas-box").innerHTML = '<div class="mdui-text-color-theme-disabled" style="font-family:\'Mina\'">============== 设备信息 ==============<br>设备类型：' + DeviceInfo.systemType + "<br>设备系统：" + DeviceInfo.system + " " + DeviceInfo.systemVersion + "<br>当前浏览器：" + DeviceInfo.browser + " " + DeviceInfo.browserVersion + "<br>浏览器内核：" + DeviceInfo.browserEngine + "<br>是否支持 WebGL：" + (DeviceInfo.supportWebGL ? "是" : "否") + "<br>=========== 等待启动模拟器 ===========</div>", switchPanel(5)
    })
}
PIXI.CanvasRenderer.registerPlugin("graphics", PIXI.CanvasGraphicsRenderer), PIXI.CanvasRenderer.registerPlugin("sprite", PIXI.CanvasSpriteRenderer), Loader.add([{ name: "tap", url: "./img/Tap.png" }, { name: "tap2", url: "./img/Tap2.png" }, { name: "tapHl", url: "./img/TapHL.png" }, { name: "drag", url: "./img/Drag.png" }, { name: "dragHl", url: "./img/DragHL.png" }, { name: "flick", url: "./img/Flick.png" }, { name: "flickHl", url: "./img/FlickHL.png" }, { name: "holdHead", url: "./img/HoldHead.png" }, { name: "holdHeadHl", url: "./img/HoldHeadHL.png" }, { name: "holdBody", url: "./img/Hold.png" }, { name: "holdBodyHl", url: "./img/HoldHL.png" }, { name: "holdEnd", url: "./img/HoldEnd.png" }, { name: "holdEndHl", url: "./img/HoldEndHL.png" }, { name: "judgeLine", url: "./img/JudgeLine.png" }, { name: "clickRaw", url: "./img/clickRaw128.png" }, { name: "songNameBar", url: "./img/SongsNameBar.png" }, { name: "progressBar", url: "./img/ProgressBar.png" }, { name: "judgeIconFalse", url: "./img/judgeIcons/false.png" }, { name: "judgeIconC", url: "./img/judgeIcons/c.png" }, { name: "judgeIconB", url: "./img/judgeIcons/b.png" }, { name: "judgeIconA", url: "./img/judgeIcons/a.png" }, { name: "judgeIconS", url: "./img/judgeIcons/s.png" }, { name: "judgeIconV", url: "./img/judgeIcons/v.png" }, { name: "judgeIconPhi", url: "./img/judgeIcons/phi.png" }, { name: "soundTap", url: "./sound/Hitsound-Tap.ogg" }, { name: "soundDrag", url: "./sound/Hitsound-Drag.ogg" }, { name: "soundFlick", url: "./sound/Hitsound-Flick.ogg" }, { name: "levelOverEZ", url: "./sound/levelOver/ez.ogg" }, { name: "levelOverHD", url: "./sound/levelOver/hd.ogg" }, { name: "levelOverIN", url: "./sound/levelOver/in.ogg" }, { name: "levelOverAT", url: "./sound/levelOver/at.ogg" }, { name: "levelOverSP", url: "./sound/levelOver/sp.ogg" }]).load(function(e) {
    for (const s in e.resources)
        if (s.indexOf("sound") <= -1 && s.indexOf("judgeIcon") <= -1 && s.indexOf("levelOver") <= -1) {
            if (textures[s] = e.resources[s].texture, "clickRaw" == s) {
                let e = [];
                for (let t = 0; t < Math.floor(textures[s].height / textures[s].width); t++) {
                    var i = new PIXI.Rectangle(0, t * textures[s].width, textures[s].width, textures[s].width),
                        i = new PIXI.Texture(textures[s].baseTexture, i);
                    e.push(i)
                }
                textures[s] = e
            }
        } else 0 <= s.indexOf("judgeIcon") ? textures.judgeIcon[s.replace("judgeIcon", "").toLowerCase()] = e.resources[s].texture : 0 <= s.indexOf("sound") ? (textures.sound[s.replace("sound", "").toLowerCase()] = e.resources[s].sound, textures.sound[s.replace("sound", "").toLowerCase()].play({ volume: 0 })) : 0 <= s.indexOf("levelOver") && (textures.sound.levelOver[s.replace("levelOver", "").toLowerCase()] = e.resources[s].sound, textures.sound.levelOver[s.replace("levelOver", "").toLowerCase()].loop = !0);
    setProgress("loading-sources", "全部资源加载完毕！", 1), setTimeout(() => {
        if (panelInst.closeAll(), panelInst.open(1), getSearchQuery("url") && "" != getSearchQuery("url")) {
            var i, s = decodeURIComponent(getSearchQuery("url")).split("?")[0];
            let e = decodeURIComponent(getSearchQuery("url")).split("?")[1],
                t = {};
            if (e)
                for (i of e.split("&")) t[i.split("=")[0]] = i.split("=")[1];
            mdui.$("#loading-chart-group").removeClass("mdui-hidden"), mdui.$.ajax({ method: "GET", url: s, data: t, dataType: "arraybuffer", xhrFields: { responseType: "arraybuffer", withCredentials: !0, onprogress: e => { e.lengthComputable && setProgress("loading-chart-zip", "正在下载在线文件（" + (e.loaded / e.total * 100).toFixed(2) + "%）...", e.loaded / e.total) } }, success: (e, t, i) => { setProgress("loading-chart-zip", "下载在线文件完成！", 1), decodeZip(new File([i.response], "chart.zip", { type: "application/zip", lastModified: Date.now() })) }, error: (e, t) => { console.error("解析在线文件时发生了错误，请检查源文件是否可用。\n" + String.fromCharCode.apply(null, new Uint16Array(t.response))) } })
        }
    }, 500)
});